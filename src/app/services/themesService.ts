import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root',
})
export class ThemesService {
  BROWSER = [
    {
      title: 'Все про HTTP/HTTPS ',
      quest: `
      HTTP - это протокол используемы для взаимодействия клиента с сервером.

      HTTP запрос сотоит из URL, BODY, HEADERS, METHOD

      `,
    },
    {
      title: 'Как браузер загружает html',
      quest: `
      Запрос на сервер:
      Браузер отправляет HTTP-запрос на сервер по введенному пользователем URL.

      1 Получение HTML:
        Сервер отправляет HTML-код в ответ на запрос браузера.

      2 Парсинг и создание DOM:
        Браузер парсит(анализирует) HTML, создает DOM - древовидное представление структуры документа.

      2 Построение CSSOM:
        Браузер строит CSSOM (CSS Object Model).

      3 Создание Render Tree:
        DOM и CSSOM объединяются в Render Tree, представляющий структуру отображения элементов.

      5 Расчет макета:
        Браузер определяет размеры и расположение элементов на странице (Layout).

      6 Отрисовка и отображение:
        Происходит отрисовка
        Эти шаги обеспечивают процесс загрузки и отображения HTML-страницы в браузере.
      `,
    },
    {
      title: 'Что происходит, когда мы вводим url в строку браузера',
      quest: `
      1. Браузер ищет IP сервера в локальном кэше, история браузера, в ОС. кэше  роутера и т.д
      2. Браузер отправляет запрос к DNS-серверам, чтобы получить IP сервера
      3. Браузер после получения IP устанавливает TCP соединение с этим сервером
      4. Браузер отправляет HTTP-запрос, чтобы получить контент сайта
      5. Сервер обрабатывает запрос
      6. Сервер отправляет ответ браузеру
      7. Браузер обрабатывает полученный ответ
      `,
    },
  ];
  CSS = [
    {
      title: 'Position',
      quest: `
    static
    Это значение позволяет элементу находиться в обычном его состоянии, расположенном на своём месте в документе. Свойства top, right, bottom, left и z-index не применяются к данному элементу. Это значение по умолчанию.

    relative
    Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно себя на основе значений top, right, bottom и left.

    absolute
    Элемент удаляется из обычного потока документа, и для элемента в макете страницы не выделяется дополнительное пространство.
    Он располагается относительно своего ближайшего спозиционированного предка, если такой есть; в противном случае он помещается
    относительно исходного содержащего блока.
    Его конечная позиция определяется значениями top, right, bottom, и left


    fixed
    Элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство.
    Он позиционируется относительно исходного браузерного окна

    `,
    },
    {
      title: 'Селекторы',
      quest: `

    Приоритет селекторов:
    Если мы пользуемся !important, то он имеет наивыысший пиоритет.
    1. Инлайн стили
    2. селекторы типов элементов
    3. селекторы классов
    4. селекторы идентификаторов


    При одинаковой силе последний селектор перезатирает свойства предыдущих.
    Но селектор .class1 .class2 сильнее чем просто .class2



    .class1 .class2 {} = Этот селектор выбирает все элементы с классом .class2, которые вложены в элементы с классом .class1.
    .class1 > .class2 {} =  Этот селектор выбирает все элементы с классом .class2, которые являются (прямыми потомками) элементов с классом .class1.
    .class1.class2 {} =  Это означает, что вы выбираете элемент, который имеет оба указанных класса. У элемента должны одновременно присутствовать оба класса для того, чтобы селектор сработал.
    .class1, .class2 {} = Этот селектор будет содержать общие классы для обоих классов. Они применяется и к class1 и к class2
    .class1[class2] {} = Этот стиль применится к элементам с классом .class1, у которых есть атрибут class2.
    .class1:not(.class2) {} = Этот стиль применится к элементам с классом .class1, но не имеющим класс .class2.
    .class1 + .class2 {} = Этот стиль применится к элементам с классом .class2, которые непосредственно следуют за элементами с классом .class1.
    .class1 ~ .class2 {} = Применится к элементам с классом .class2, которые идут после элементов с классом .class1 на том же уровне вложенности.


    `,
    },
  ];
  JS = [
    {
      title: 'Копирование объектов',
      quest: `
      Можно сделать глубокое копирование с помощью функции structuredClone(obj),
      Но это нововведение. Раньше я делала это с помощью рекурсии.
      Есть еще один вариант, который часто используют. это JSON.parse(JSON.stringify(obj))
      Но этот способ игнорирует такие значения как: undefined, function, Date,
      потому что в JSON нет таких типов.
      Еще можно сделать негбокое копирование с помощью спред оператора и Object.assigne({},  obj)

      `
    },
    {
      title: 'WEB WORKER, SERVISE WORKER',
      quest: `
    WEB WORKER - это механизм, который позволяет выполнять скрипты в фоновом режиме,
    в отдельном потоке, отдельном от основного потока выполнения JavaScript в веб-приложении.
    Это позволяет выполнять тяжелые вычисления, обрабатывать задачи в фоновом режиме и
    не блокировать основной поток браузера, что способствует более отзывчивому пользовательскому
    интерфейсу.WEB WORKER это отдельный js файл, не имеющий доступа к DOM юраузера и объекту window

    SERVISE WORKER - сервис-воркеры позволяют приложениям продолжать работу в
    автономном режиме в случае потери подключения к интернету. Service Worker используется для
    кэширования ресурсов, таких как HTML-страницы, стили, JavaScript-файлы, изображения и другие
    файлы, полученные с сервера. Эти ресурсы сохраняются в локальном кэше браузера.
    Когда веб-приложение отправляет запрос на сервер, Service Worker может перехватить этот запрос
    и решить, каким образом ответить на него.
    Если есть активное интернет-соединение, Service Worker может отправить запрос на сервер и
    обновить кэш данными с сервера. Если интернет-соединение отсутствует или запрос
    на сервер завершается ошибкой, Service Worker может вернуть ресурсы из локального кэша.
        `,
    },
    {
      title: 'Операторы REST SPREAD',
      quest: `

      Рест оператор используется для сбора аргументов в функции или элементов в массиве. Пример:

        function sum(...numbers) {
          return numbers.reduce((acc, num) => acc + num, 0);
        }
        console.log(sum(1, 2, 3, 4));



      Спрэд оператор используется для распаковки значений из массивов, объектов или строк. Вот пример использования спрэд-оператора с массивом:

        const arr1 = [1, 2, 3];
        const arr2 = [...arr1, 4, 5];

        Или для удаления свойств объекта:

        let obj = {
          a:1,
          b:2,
          c:3
        }

        const {a,b, ...objj} = obj


        console.log(objj)// {c:3}

      `,
    },
    {
      title: 'Наследование в JS',
      quest: `
      В JavaScript существуют три основных типа наследования:

      1. Прототипное наследование - каждый объект имеет свойство-прототип, которое наследует свойства и методы от
      родительского объекта. При обращении к свойству или методу объекта, которого нет в нем самом, поиск происходит в его прототипе.
      let a=12
      a.toString() это прототипное наследование


      Классическое наследование:
      2. Классическое наследование - основано на классах и объектах-экземплярах.
      Класс определяет общие свойства и методы, которые наследуются экземплярами этого класса

      Миксин наследование:
      3. Миксин-наследование - позволяет объектам наследовать свойства и методы от нескольких источников,
      не создавая полноценную иерархию наследования.
      Это позволяет легко объединять функциональность из разных источников.
      Классическое наследование на основе классов в JavaScript ограничено использованием одного родительского класса,
      но с помощью миксин-наследования можно добавить функциональность нескольких различных источников.

      const canSwim = {
        swim() {
          console.log("Swimming...");
        }
      };

      const canFly = {
        fly() {
          console.log("Flying...");
        }
      };

      class Duck {
        constructor() {
          Object.assign(this, canSwim, canFly);
        }
      }

      const duck = new Duck();

      duck.swim(); // Выводит "Swimming..."
      duck.fly(); // Выводит "Flying..."

      `,
    },
    {
      title: 'Promse.all, Promise.allSettled, Promise.sell',
      quest: `

    Promise.all:
    Возвращает новый промис, который разрешается, когда все переданные промисы разрешаются, и отклоняется, если хотя бы один из них отклоняется.
    Промисы, переданные в Promise.all, также выполняются параллельно.
    Результатом Promise.all будет массив значений, разрешенных каждым промисом, в том порядке, в котором они были переданы.

    Promise.race:
    Как только один из переданных промисов разрешится или отклонится,
    результат (значение или ошибка) будет передан в соответствующий обработчик then или catch,
    и остальные промисы будут проигнорированы.

    Promise.allSettled:
    Очень похож на метод Promise.all(), но работает немного по-другому. В отличие от Promise.all(),
    Promise.allSettled() ждёт выполнения всех промисов, при этом неважно, завершились они успешно или с ошибкой.

    `,
    },
    {
      title: 'Методы массивов. Мутабельные и иммутабельные',
      quest: `

      Мутабельные методы:
      pop: Удаляет последний элемент из массива.
      shift: Удаляет первый элемент из массива.
      push: Добавляет один или несколько элементов в конец массива.
      unshift: Добавляет один или несколько элементов в начало массива.
      reverse: Переворачивает порядок элементов в массиве.
      sort: Сортирует элементы массива (по умолчанию, как строки).
      fill: Заполняет все элементы массива значением? переданным как аргумент.
      splice: Удаляя или заменяет элементы массива. splice(1,3,'a','b')//

      Иммутабельные методы:
      slice(): Возвращает подмассив (вырезанную часть) массива, не изменяя оригинальный массив. splice(1,3)
      concat: Объединяет два или более массива, создавая новый массив.
      map: Создает новый массив, содержащий результат вызова предоставленной функции для каждого элемента.
      filter: Создает новый массив, содержащий только те элементы, для которых предоставленная функция возвращает true.
      reduce: Применяет функцию к аккумулятору и каждому элементу массива (слева направо) для свертывания массива в одно значение.
      every: Проверяет, удовлетворяют ли все элементы массива предоставленное условие.
      some: Проверяет, удовлетворяет ли хотя бы один элемент массива предоставленное условие.
      find: Поиска первого элемента в массиве, который удовлетворяет условию в функции обратного вызова.
      Этот метод возвращает значение первого найденного элемента или undefined, если элемент не найден.

      `,
    },
    {
      title: 'PROTO VS PROTOTYPE',
      quest: `
      Все объекты в js имеют __proto__.
      prototype есть только у функций и классов(потому что класс это синтаксический сахар для функции)
      __proto__ ссылается на прототип класса, с помощь. которого был создан.
      Например
      let name = 18 // new String(18)
      let age = 18 // new Number(18)

      у name нет prototype, у него есть proto, которое ссылается на String.prototype

      class Car {}
      function F1(){}

      let b = new F1()  //b.__proto__ === F1.prototype будет true
      console.log(F1.__proto__ === Function.prototype) //true

      let a = new Car() //a.__proto__ === Car.prototype будет true
      console.log(Car.__proto__ === Function.prototype)//true




      `,
    },
    {
      title: 'Дексрипрторы',
      quest: `

     В контексте JavaScript дескрипторы — это объекты, которые определяют свойства и могут быть использованы для более тонкой настройки работы
     свойств объектов.

     Использывание:
     const obj = {};

    Object.defineProperty(
      obj,
      'value1', //название добавляемого свойства
      {
    value: 10,//Устанавливает первоначальное значение
    writable: false,//Доступно только для чтения
    enumerable:false,// Недоступен при итерациях
    configurable:false//можно ли удалить или модифицировать с помощью Object.defineProperty
});
    `,
    },
    {
      title: 'Event loop, как он работает?',
      quest: `
      Изначально все наши функции попадают в callStack и все синхронные функции сразу же выполняются по очереди и выходят оттуда.
      А все асинхронные события отправляются в webApi, откуда после выполнения асинхронной функции они попадают в caalback queue,
      где есть два контейнераЖ микротаски и макротаски. Первыми выполняются все микротаски и только потом выполняются макротаски`,
    },
    {
      title: 'Map и Set',
      quest: `
      Map - коллецкция ключ - значение. Ключем может быть другой что угодно. при этом map сохраняет последовательность в цикле.
      Set - коллекция уникальных значений

      Вот основные методы, предоставляемые объектом Map:

      set(key, value): Устанавливает значение для указанного ключа в Map.
      get(key): Возвращает значение, связанное с указанным ключом.
      has(key): Проверяет, существует ли ключ в Map.
      delete(key): Удаляет значение, связанное с указанным ключом.
      clear(): Удаляет все значения из Map.
      size: Возвращает количество элементов в Map.
      keys(): Возвращает итератор по ключам Map.

      const keysIterator = myMap.keys();
      for (const key of keysIterator) {
        console.log(key);
      }

      values(): Возвращает итератор по значениям Map.

      const valuesIterator = myMap.values();
      for (const value of valuesIterator) {
        console.log(value);
      }

      entries(): Возвращает итератор по массивам [ключ, значение] для каждого элемента Map.

      const entriesIterator = myMap.entries();
      for (const [key, value] of entriesIterator) {
        console.log(key, value);
      }

      forEach(callbackFn): Вызывает указанную функцию обратного вызова для каждого элемента Map.

      myMap.forEach((value, key) => {
        console.log(key, value);
      });






      Вот основные методы, предоставляемые объектом Set:

      add(value): Добавляет значение в Set. Если значение уже присутствует, метод не выполняет никаких изменений.
      delete(value): Удаляет значение из Set. Возвращает true, если значение было в Set и успешно удалено, и false в противном случае.
      has(value): Проверяет, содержится ли значение в Set. Возвращает true, если значение присутствует, и false в противном случае.
      clear(): Удаляет все значения из Set.
      size: Возвращает количество элементов в Set.
      keys() (или values()): Возвращает итератор по значениям в Set. Обратите внимание, что у Set ключи и значения совпадают.
      entries(): Возвращает итератор по массивам [значение, значение] для каждого элемента Set.
      forEach(callbackFn): Вызывает указанную функцию обратного вызова для каждого элемента Set.

      `,
    },
    {
      title: 'Как сделать объект иммутабельным',
      quest: `
      С помощью Object.freeze. Он запрещает удаление, добавление или изменение текущих свойств.
      Но мы по прежнему сможем поменять свойства вложенных объектов.


      Object.seal используется для запрета добавления новых свойств к объекту и удаления существующих свойств.
      Однако, оно также делает все существующие свойства объекта неперечислимыми (non-configurable),
      что означает, что их нельзя будет удалить с помощью оператора delete. Это делает объект "запечатанным" (sealed).
      Но свойства по-прежнему могут быть изменены.

      Когда мы захотим что то поменять в иммутабельном стиле, мы должны будем скопировать объект
      с помощью Object.assigne({}, obj) или {...obj}.

      Так же assigne позволяет объединить методы, исключив дубликаты ключей
      `,
    },
    {
      title: 'Как сделать поле класса приватным',
      quest: `
      Есть соглашение, что если поле является привантым, то нужно писать перед ним _, но в последния версиях JS появилась возможность
      добавить перед полем "#" и поле станет приватный. то есть нельзя быдет обратиться к немук извне. Если в TS то Private`,
    },
    {
      title: 'В чем отличие примитивных и непримитивных типов данных',
      quest: `
      Во первых,ссылочные типы могут иметь методы, свойства.
      Во вторых, примитивы сравниваются по значению, а непримитивы по ссылке.
      В третьи, примитивы являются иммутабельными. Мы не можем их изменять, а можем только перезаписать
      `,
    },
    {
      title: 'Что такое замыкание',
      quest: `
      Замыкание (closure) - это свойство функции сохранять доступ к переменным из
      внешней области видимости, даже после того, как эта область видимости завершила свою работу.`,
    },
    {
      title: 'Что делать если потерял this?',
      quest: `
      Привязать с помощью .bind или apply. Bind не вызывает, а только связывает. А apply вызыввает сразу`,
    },
    {
      title: 'Что такое частичное применение? Каррирование?',
      quest: `
      Частичное применение это когда мы вызываем функцию с некоторыми, но не всеми параметрами, и возвращаем новую функцию, которая уже принимает остальные параметры.

      Пример 1:

      const f1 = (a, b) => {
        return a + b;
      };

      const f2 = (a) => (b) => f1(a, b);

      const f3 = f2(1)

      console.log(f3(2)) // 3

      Пример 2:

      const f1 = (a, b) => {
        return a + b;
      };

      const f2 = f1.bind(null, 1 )
      console.log(f2(2)) // 3


      Каррирование это преобразование одной функции, которая принимает несколько аргументов в последовательность вложеннных
      функций, которые принимают по одному параметру.

      Пример:

      const f1 = (a, b) => {
        return a + b;
      };

      const f2 = a=>b=>a+b
      f2(1)(2) // 3

      `,
    },
    {
      title: 'Как удалить поле из объекта в иммутабельном стиле?',
      quest: `Скопировать с помощью спред оператора и удалить уже из нового объекта`,
    },
    {
      title: 'Как работает .reduce()',
      quest: `

reduce() - это метод массивов в JavaScript, который применяет функцию к аккумулятору и каждому элементу массива (слева направо),
чтобы свести массив к одному значению. Вот простое объяснение:

Аргументы:

Функция обратного вызова (callback): Эта функция выполняется для каждого элемента массива и принимает четыре параметра: аккумулятор,
 текущий элемент, текущий индекс и сам массив.
Начальное значение аккумулятора (опционально): Значение, которое будет использоваться в качестве первого аргумента при первом вызове
функции обратного вызова.
Как работает:

reduce() начинает с первого элемента массива, используя его значение и начальное значение (если оно предоставлено) в качестве аккумулятора.
Затем функция обратного вызова применяется к следующему элементу массива, используя текущее значение аккумулятора и значение элемента.
Этот процесс повторяется для каждого элемента массива, каждый раз обновляя значение аккумулятора.
В конце reduce() возвращает окончательное значение аккумулятора.
Пример:


const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0);

console.log(sum); // 15`,
    },
    {
      title: 'Что такое промисы',
      quest: `
      Promise это класс в js для работы работы с асинхронным кодом
      Промисы имеют три состояния:

      Ожидание (Pending): Начальное состояние, когда промис создан, но результат еще не известен.

      Исполнено (Fulfilled): Операция завершена успешно, и промис вернул результат.

      Отклонено (Rejected): Операция завершена с ошибкой, и промис вернул ошибку.

      Конструктор принимает два метода Resolve и reject. Res отвечает за успешное выполнение а reject вызывается,
      чтобы вернуть оишбку при неудачном выполнении.

      Промисы в JavaScript действительно имеют три основных метода: then, catch и finally:

      then:
      Используется для обработки успешного завершения промиса. Принимает колбэк, который выполняется, когда промис успешно завершается.

      catch:
      Используется для обработки ошибок, произошедших во время выполнения промиса. Принимает колбэк, который выполняется в случае ошибки.

      finally:
      Используется для указания блока кода, который будет выполнен независимо от того, успешно завершился промис или произошла ошибка. Принимает колбэк, который выполняется всегда, независимо от результата промиса.

      `,
    },
    {
      title: 'В чем отличие стрелочных функций?',
      quest: `
      1. Не имеют внутри себя объект arguments
      2. Нельзя обратиться до их объявление
      3. Не имеют своего this. Берет извне
      4. синтаксис
      `,
    },
    {
      title: 'Что такое рекурсия?',
      quest: `
      Это функцияЮ вызывающая сама себя
      `,
    },
  ];
  TS = [
    {
      title: 'Отличие абстрактных классов от интерфейса',
      quest: `
      Абстрактный класс в TypeScript:

      Может содержать абстрактные методы (без реализации) и конкретные методы (с реализацией).
      Может содержать переменные класса (поля).
      Поддерживает одиночное наследование.
      Может иметь конструктор.

    `,
    },
    {
      title: 'Объединение и пересечение типов',
      quest: `
     Объединение типов = number | string // Может быть либо string либо number, либо работать как &, если это не примитивные данные
     Пересечение типов = interface1 & interface2 // должен содержать методы и свойства обеих интерфейсов
    `,
    },
    {
      title: 'Отличие type vs interface',
      quest: `

    Interface, когда вам нужно описать форму объекта.
    Type, когда вам нужно создать юнион тип/объединенный тип или тип, который не является объектом: type Age = number.


    type:
    1. можно задать тип для примитивного значения
    type id = number
    2. Можно создать юнион тип/объединенный тип
    3. Тип не могжет быть объявлен дважды. А интерфейс в таком случае расширяют предыдущий интерфейс

    Пример:

    type a = string:number

    Пример 2:

    type Num = {
      age:number
    };

    type Str = {
      name: string
    };

    type NumStr = Num | Str; // Объединение или одно из двух


    interface: Интерфейсы обычно используются для описания формы объектов или контрактов, а не для создания примитивных значений типов.
    `,
    },
    {
      title: 'Что такое дженерики?',
      quest: `
      Да, с помощью дженериков в TypeScript вы можете создавать обобщенные типы данных, которые могут работать
      с различными типами. Эти обобщенные типы могут быть использованы как переменные для различных типов данных,
      обеспечивая гибкость и повторное использование кода.

      Преимущества использования дженериков:

      Универсальность: Дженерики позволяют писать более гибкий и универсальный код, который может работать с разными типами данных.

      Повторное использование: Дженерики способствуют повторному использованию кода, так как вы можете создавать универсальные компоненты.`,
    },
    {
      title: 'Отличие unknown от any?',
      quest: `

1. TypeScript отключает для any большинство проверок типов, что может привести к потенциальным ошибкам во время выполнения.

1. Переменные типа unknown более безопасны, чем any, потому что TypeScript не позволяет выполнить большинство
операций с unknown без явных проверок типов или приведения типов.
Использование unknown обеспечивает более строгую безопасность типов по сравнению с any.


let variable: unknown = "Привет";
console.log(variable.toUpperCase()); // Работает без ошибок

.......................................................

let variable: unknown = "Привет";

if (typeof variable === "string") {
  console.log(variable.toUpperCase());}
 //Без проверки будет ошибка
      `,
    },
    {
      title: 'Type guards',
      quest: `

Type guards (стражи типов) в TypeScript - это проверки типов, которые помогают компилятору TypeScript узнать точно, с каким типом работать.
Это позволяет писать более безопасный код, уменьшая вероятность ошибок.
TypeScript поддерживает несколько видов type guards:

1 Типовые проверки (Typeof type guards):
Основаны на операторе typeof.

2 Инстансоф типовые проверки (Instanceof type guards):
Основаны на операторе instanceof.

3 Функции, которые возвращают булево значение и используются в качестве типовых стражей.

`,
    },
    {
      title: 'В чем отличие enum и const enum',
      quest: `
      Перечисления в TypeScript нужны для того, чтобы задать именованные значения, которые часто используются в коде.
      Это делает код более читаемым, помогает избежать ошибок и облегчает работу с определенными типами данных.

      Компиляция:

      Во время компиляции enum превращается в объект JavaScript, который может быть использован во время выполнения.
      В отличие от обычного enum, const enum во время компиляции полностью удаляется, и в JavaScript код не оставляется.

`,
    },
    {
      title: 'Utility типы pick, omit, parameters, return и т.д',
      quest: `
      Pick<T, K>: Позволяет выбрать из типа T только те свойства, которые перечислены в K

      Omit<T, K>: Позволяет исключить из типа T те свойства, которые перечислены в K.

      Parameters<T>: Получает тип параметров функции T.

      ConstructorParameters<Type> - извлекает типы аргументов конструктора Type.

      ReturnType<T>: Получает тип возвращаемого значения функции T.

      Partial<T>: делает все свойства объекта типа T необязательными.

      Required<T> - делает все свойства объекта типа T обязательными.

      Readonly<T> - делает все свойства объекта типа T доступными только для чтения.

      Record<Keys, Type> - создает тип, который является записью с ключами, определенными в первом параметре, и значениями типа, определенного во втором параметре.

      type Keys = 'a' | 'b' | 'c';
      type RecordType = Record<Keys, number> = { a: number, b: number, c: number }




      Extract<Type, Union> - извлекает из типа Type только те типы, которые присутствуют в Union.
      type A = 'a' | 'b' | 'c';
      type B = 'a' | 'b'| 'e';
      type C = Extract<A, B>;//тип "a" | "b"

      NonNullable<Type> - извлекает тип из Type, исключая null и undefined.

      let value: string | null | undefined;
      let nonNullableValue: NonNullable<typeof value>;
      // теперь nonNullableValue это string


      Uppercase<StringType>, Lowercase<StringType>, Capitalize<StringType>, Uncapitalize<StringType> - это утилитные типы для манипуляции строками, которые изменяют регистр строки в соответствии с их именем.

      type Uppercased = Uppercase<'hello'>; // 'HELLO'
      type Lowercased = Lowercase<'Hello'>; // 'hello'
      type Capitalized = Capitalize<'hello'>; // 'Hello'
      type Uncapitalized = Uncapitalize<'Hello'>; // 'hello'

`,
    },
    {
      title: 'Для чего нужен тип never?',
      quest: `
        Тип never используется для представления кода, который никогда не завершает свое выполнение или не возвращает значение.
        Например функция, которая вызывает ошибку throw new Error(). Она не завершится, а вызовет ошибку.
        Или функция, которая запустила вечный цикл
`,
    },
  ];
  RXJS = [
    {
      title: 'Отличие горячего и холодного потока',
      quest: `
      Горячий поток (Subject) активен независимо от того, есть ли подписчики,
      в то время как холодный поток (observable) начинает исполнение только при подписке.`,
    },
    {
      title: 'Higher order observables',
      quest: `
      Higher order observables - потоки, создающие другие потоки.
      of(1,2,3,4).pipe(
        map(value=>of(value))
      )

      или

      of(1,2,3,4).pipe(
        map(value=>of(value))
      ).subscribe(value=>value.subscribe())

      `,
    },
    {
      title: 'Виды Subject',
      quest: `
      Subject - это обычный subject без начального значения, который является и наблюдателем и наблюдаемым.

      BehaveurSubject - это subject с первоначальным значением. Он хранит последнее отправленное значение и передает его новым подписчикам при подписке.
      имеет дополнительный метод и свойство, которых нет у обычного Subject. Вот они:
      getValue(): Этот метод возвращает текущее значение, хранящееся в BehaviorSubject. Это полезно, если вам
      нужно получить текущее значение без подписки.
      Свойство value предоставляет доступ к текущему значению

      ReplaySubject -Запоминает несколько (или все) последних значений и передает их новым подписчикам при подписке.
      ReplaySubject.getBufferedValues(). Этот метод полезен, если вы хотите получить доступ к текущему состоянию буфера.
      new ReplaySubject<number>(2, 1500); //запомнит 2 значение в течение 1500милисекундн. Затем забудет

      AsyncSubject - Хранит только последнее значение и передает его только при вызове complete().
      `,
    },
    {
      title: 'Мультикастинг',
      quest: `
      Мультикастинг в RxJS — это механизм, позволяющий переиспользовать поток событий между несколькими подписчиками,
      избегая повторного выполнения вычислений при каждой новой подписке.

      const get = ajax.get('https://jsonplaceholder.typicode.com/posts/1').pipe(share())
      get.subscribe()
      get.subscribe()//Запрос отправится лишь один раз
      `,
    },
    {
      title: 'Аналог Promise.all в RxJS',
      quest: `
     CombineLatest и ForkJoin.

     CombineLatest Создает новый поток, который излучает последние значения от каждого исходного потока,
     ак только хотя бы один из них излучает новое значение.

     ForkJoin  Ожидает завершения всех исходных потоков и излучает массив их последних значений.
     `,
    },
    {
      title: 'Комбинирование потоков в Rxjs',
      quest: `
      concat: Объединяет несколько потоков в один, но сначала дожидается завершения предыдущего потока, прежде чем начать следующий.
      const source1 = timer(1000).pipe(map(()=>'1'));
      const source2 = timer(500).pipe(map(()=>'2'));
      const func = concat(source1, source2);
      func.subscribe(value => console.log(value)); ///Через 1 секеудну 1, после, через 0.5 секунд 2

      merge: Объединяет несколько потоков в один, сохраняя порядок поступления событий от всех потоков. То есть потоки идут параллельно
      const source1 = timer(1000).pipe(map(()=>'1'));
      const source2 = timer(500).pipe(map(()=>'2'));
      const func = merge(source1, source2);
      func.subscribe(value => console.log(value)); ///Через 0.5 секеудн 2, после, через 0.5 секунд 1
     `,
    },
    {
      title: 'Когда и как нужно отписываться, что если не отписаться?',
      quest: `
      Отписка в RxJS важна для предотвращения утечек ресурсов и избыточного использования памяти. Постепенное накопление утекшей памяти может
      привести к увеличению потребления памяти приложением, в конечном итоге вызвав проблемы с производительностью и стабильностью приложения.

    Метод 1 : takeUntil(this.destroy$)

    export class MyComponent implements OnDestroy {
      private destroy$ = new Subject<void>();

      constructor() {
        of(1)
          .pipe(takeUntil(this.destroy$))
          .subscribe();
      }

      ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
      }
    }

    Метод 2: takeUntilDestroyed()

    export class MyComponent {
      constructor() {
        interval(1000)
          .pipe(takeUntilDestroyed())
          .subscribe();
      }
    }

    или


    export class MyComponent implements ngOnInit {
      destroyRef = inject(DestroyRef)
      ngOnInit() {
        interval(1000)
          .pipe(takeUntilDestroyed(this.destroyRef))
          .subscribe();
      }
    }

    Метод 3: Использование async пайпа в шаблоне.

      `,
    },
    {
      title: 'Как создать свой оператор в RxJs',
      quest: `
      Чтобы создать оператор, нужно создать функцию, которая принимает исходный Observable и
      возвращает новый измененный Observable.

      Пример:

      function multiplyBy(factor: number): OperatorFunction<number, number> {
        return (source: Observable<number>) =>
          source.pipe(
            map(value => value * factor)
          );
      }

      // Использование
      const source = of(1,2,3)

      source.pipe(multiplyBy(10)).subscribe(console.log)///10,20,30

      Описание:

      multiplyBy - это функция, которая принимает один аргумент factor, представляющий число, на которое будут умножаться значения в потоке.
      OperatorFunction<number, number>:

      OperatorFunction - это обобщенный интерфейс RxJS, представляющий оператор, который принимает значения одного типа (number в этом случае) и возвращает значения того же типа.
            Возвращаемая функция:

      multiplyBy возвращает функцию, которая является оператором. Эта функция принимает source (исходный Observable) и возвращает новый Observable, который модифицирован согласно определенному оператору.
      source.pipe(...):

      source - это исходный поток значений типа number, который будет модифицирован оператором.
      source.pipe(...) - метод pipe принимает операторы и возвращает новый Observable, который представляет собой результат применения этих операторов к исходному потоку.
      map(value => value * factor):

      map - это стандартный оператор RxJS, который применяет функцию к каждому значению в потоке.
      В данном случае, используя map, каждое значение в потоке умножается на factor.
      `,
    },
  ];
  ANGULAR = [
    {
    title: 'Pipe в агуляр. Pure vs ImPure',
    quest: `
    В Angular пайпы (pipes) представляют собой функции, используемые для преобразования данных в шаблонах.
     Они позволяют изменять отображение данных перед выводом их в пользовательском интерфейсе.

     В ангуляре есть встроенные пайпы (date, async, json, currency и т.д).
     Мы так же можем написать свои пайпы:

    @Pipe({
      name: 'multiplier'
    })
    export class MultiplierPipe implements PipeTransform {
      transform(value: number, factor: number = 1): number {
        return value * factor;
      }
    }

    ...

    <p>Multiplied Value: {{ originalValue | multiplier:2 }}</p>

    Есть понятие чистых пайпов и нечистых пайпов.
    Чистый пайп пересчитывается только при изменении значения, а не при каждом рендере страницы, в отличие от нечистого.
    По умолчанию любой пайп является чистым.
    Чтобы сделать пйп нечистым, нужно в декораторе указать pure:false
    `
    },
    {
      title: "Resolution modifier: @Self, @SkipSelf, @Host, @Options",
      quest:`
      В Angular skipSelf, self, optional, и host представляют собой опции, которые могут использоваться
      в конструкторе инжектора компонентов для уточнения, как должны разрешаться зависимости.

      @SkipSelf()
      Декоратор, который указывает инжектору компонента пропустить поиск зависимости в собственном инжекторе
      и начать поиск в инжекторе родительского компонента.

      @Self()
      Декоратор, который говорит инжектору компонента использовать только свой собственный инжектор
      для разрешения зависимости, а не подниматься вверх по иерархии компонентов.

      @Optional()
      Декоратор, который указывает инжектору компонента, что зависимость не является обязательной.
      Если зависимость не найдена, инжектор не выдаст ошибку, а просто установит значение в null
      (или предоставит значение по умолчанию, если оно определено).

      @Host()
      Декоратор, который указывает, что нужно искать зависимость только в родительском КОМПОНЕНТ-инжекторе, пропустив свой

      `
    },
    {
      title: 'Guards в ангуляр',
      quest: `
      Это классы, которые используются для защиты маршрутов.
      Пример:

      @Injectable({
        providedIn: 'root'
      })
      export class AuthGuard implements CanActivate {

        constructor(private authService: AuthService, private router: Router) {}

        canActivate(
          next: ActivatedRouteSnapshot,
          state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {

          if (this.authService.isAuthenticated()) {
            // Пользователь аутентифицирован, разрешаем активацию маршрута
            return true;
          } else {
            // Пользователь не аутентифицирован, перенаправляем на страницу входа
            this.router.navigate(['/login']);
            return false;
          }
        }
      }

      Есть canActivate для запрета зайти на страницу, и candeactivate для запрета уходить со страницы.
      Например, если изменения в форме не сохранены


      `,
    },
    {
      title: 'Как загружается ангуляр приложение в браузере',
      quest: `

      Запуск Angular-приложения в браузере включает в себя несколько шагов. Вот общий порядок событий:

      Загрузка HTML:
      Браузер начинает процесс загрузки вашего Angular-приложения с файла index.html.
      Этот файл обычно содержит базовую структуру HTML и тег <app-root>, который является
      точкой входа для вашего Angular-приложения

      Загрузка и исполнение JavaScript:
      В файле index.html есть тег <script> с атрибутом src, который указывает на файл сборки
      (обычно с именем main.js или подобным). Браузер загружает этот файл и начинает исполнять в
      нем содержащийся JavaScript-код.

      Инициализация Angular-приложения:
      Когда браузер исполняет JavaScript-код, Angular-фреймворк начинает инициализацию приложения.
      Angular ищет корневой компонент (чаще всего AppComponent), который обычно указывается в метаданных
      bootstrap модуля приложения.

      Инициализация AppModule:
      Angular создает экземпляр корневого модуля приложения (AppModule) и начинает его инициализацию.
      В модуле происходит конфигурация и регистрация всех компонентов, сервисов и других зависимостей,
      используемых в приложении.

      Создание корневого компонента:
      Когда модуль проинициализирован, Angular создает экземпляр корневого компонента (AppComponent).
      Этот компонент связывается с элементом в DOM, обозначенным как <app-root> в index.html.
      Это место является точкой входа для вашего приложения в DOM.

      Инжекция зависимостей и жизненный цикл компонентов:
      Angular управляет жизненным циклом компонентов, вызывая соответствующие методы, такие как
      ngOnInit, ngOnChanges и т.д., и предоставляя им необходимые зависимости.

      Отрисовка и обновление представления:
      Angular начинает процесс отрисовки представления на основе данных, связанных с компонентами.
      Любые изменения данных или события, такие как клики или обновления, могут вызывать перерисовку
      представления.

      Ждет событий и обновлений:
      После инициализации Angular-приложение ждет событий, таких как пользовательские взаимодействия,
      HTTP-запросы или изменения состояния, и реагирует на них, обновляя представление при необходимости.

      Эти шаги демонстрируют основной процесс загрузки и инициализации Angular-приложения в браузере.
      Отметьте, что Angular работает на клиентской стороне (frontend), и поэтому весь код
      выполняется в браузере пользователя.
      `,
    },
    {
      title: 'Ng-content, ng-template, ng-container',
      quest: `
      1. ng-contetn: используется для отображения контента, который вставаляется между тегами
      компонента. Можнои спользовать селектор чтобы определить, какой контент будет вставлен
      в определенное место внутри компонента.

      <ng-content select=".header"></ng-content> // по классу
      <ng-content select="span"></ng-content>// по тегу


      2. ng-template: определяет шаблон, который не отображается по умолчанию.
      Примеры использывания: Для отображения прелоадера

      <div *ngIf="true; else loading" ></div>
      <ng-template #loading >Загрузка</ng-template>

      Второй пример: Для отображения повторяющегося шаблона в разных частяъ кода с разными данными
      <ng-container *ngTemplateOutlet="tmplt; context:{$implisit: 'Hello'}" ></ng-container>
      <ng-template #temlt let-item >{{item}}</ng-template>

      3. ng-container: Для группировки какого то контента, для применения к этому контенту какой то директивы.
      При этом без использывания в дом дереве этого тега. Или как показано выше, для отображения ng-template
      `,
    },
    {
      title: 'Как оптимизировать ангуляр приложение',
      quest: `
      1.Lazy loading - ленивая подрузка модулей
      2.Стратегия запуска механизма обнаружения изменений OnPush,
      3.Использывание функции trackBy в цикле *ngFor,
      4.Использывание чистых пайпов,
      5.Web worker - чтобы вынести функцию со сложными вычислениями в параллельный поток`,
    },
    {
      title: 'Компиляции Ангуляр приложения',
      quest: `

      • JIT - Just-in-Time: JIT компилирует приложение в браузере во время выполнения. ng serve
      • AOT - Ahead-of-Time:  компилятор с опережением времени: компиляция AOT компилирует приложение во время сборки. npm build --aot

      JIT:
      1. Компилирует во время выполнения в браузере
      2. Увеличенный размер файлов пакета Angular
      3. Обнаружение ошибок шаблона позже во время выполнения
      4. Медленный рендеринг
      5. Больше асинхронных запросов
      6. Меньше безопас ности
      7. Меньше производительности
      8. Хорошо для разработки


      AOT:
      1. Компиляция во время сборки
      2. Меньший размер файлов пакета Angular
      3. Обнаружение ошибок шаблона раньше во время компиляции
      4. Более быстрый рендеринг
      5. Меньше асинхронных запросов
      6. Лучшая безопасность
      7. Лучшая производительность
      8. Хорошо для продакшена

      Смысл использования JIT во время ng serve:

      Быстрая разработка: JIT позволяет вам видеть изменения в реальном времени без долгих процессов сборки. Это улучшает процесс разработки и отладки.
      Удобство для разработчиков: Приложение автоматически перекомпилируется при каждом изменении кода, что облегчает эксперименты и быстрые итерации в процессе разработки.

      Смысл использования AOT в production:
      Производительность: AOT предоставляет более быстрое время запуска, так как код уже скомпилирован.
      Безопасность и оптимизации: AOT может применять различные оптимизации, а также сокращает объем кода, который отправляется на клиентскую сторону, улучшая безопасность и производительность.
      `,
    },
    {
      title: 'Иерархия инжекторов в Angular',
      quest: `
      1. NULL injector

      2. PlatformInjector

      3. RootInjector

      4. (Модели ленивой загрузки, если они есть. Обычные модули идут в root инжектор)

      5. Компонентинжектор
      `,
    },
    {
      title: 'Отличие providers и viewProviders',
      quest: `
      Когда мы провайдим зависимость с помощью viewProviders, то она у нас доступна только внутри view комонента. То есть дочерним компонентам,
      которые находятся в ng-content, она доступна не будет
      `,
    },
    {
      title: 'UseClass, UseValue, UseFactory, useExisting?',
      quest: `

     1 useClass
      Это самый простой вариант, который заключается в том, что для реализации указывается класс.
      providers: [{ provide: OptionsService, useClass: OptionsService }]

     2 useValue
      В этом варианте подставляем конкретный экземпляр значения, которое может быть любым типом данных.
      providers: [
        { provide: 'VALUE_NUMBER', useValue: 1  },
        { provide: 'VALUE_STRING', useValue: 'Текстовое значение' },
        { provide: 'VALUE2_FUNCTION', useValue: () => { return 'что-то' } },
        { provide: 'VALUE2_OBJECT', useValue: { id: 1, name: 'имя' } },
        { provide: 'VALUE2_ARRAY', useValue: [1, 2, 3] } }, ]

     3   useFactory
        Это вариант, в котором функция регистрируется как результат. Функция выполняет роль фабрики, возвращающей значение зависимости.
        providers: [{ provide: 'VALUE', useFactory: () => { return 'что-то' } }]
        Вариант useFactory отличается от варианта useValue c функцией тем, что когда возвращается функция в useValue, потом с этой
        функцией необходимо работать как с функцией, а с фабрикой получаем значение, с которым и работаем, и нет повторных вызовов функции.
        Для работы фабрики часто необходимо получать зависимости, поэтому предусмотрен механизм передачи зависимостей в функцию фабрики.
        {provide: SETTINGS_TOKEN,
        useFactory: (http: HttpClient): Observable<ISettings> => http.get<ISettings>('/assets/settings.json').pipe(shareReplay()),
        deps: [HttpClient]
        В представленном примере хотелось бы обратить внимание на свойство deps, которое осуществляет передачу зависимостей в фабрику.


     4   useExisting
        Этот вариант наиболее непонятный для новичка. Суть useExisting заключается в том, что выбирается уже существующая зависимость.
        providers: [
          { provide: 'CarService1', useClass: CarService},
          { provide: 'CarService2', useExisting: 'CarService1' }]
        Сразу отвечу на первый же вопрос – почему мы не должны написать код так:
        providers: [
          { provide: 'CarService1', useClass: CarService },
          { provide: 'CarService2', useClass: CarService }]
        Этот вариант регистрация зависимости создаст нам два экземпляра CarService. Что может доставить много не удобств
        при отладке, т.к. сервис часто хранит состояние, в результате чего произойдёт так называемый сайд-эффект.

}
      `,
    },
    {
      title: 'Как из дочернего вызвать метод родительского',
      quest: `
      В Angular дочерний компонент может вызвать метод родительского компонента с использованием @Output
      `,
    },
    {
      title: 'Структурные и шаблонные директивы в ангуляр',
      quest: `
      Директива это класс с декоратором Directive, который применяется в элементу и меняет его свойства или поведение.

    В Angular директивы делятся на два основных типа: шаблонные(атрибутные) и структурные.
    Шаблонные директивы изменяют свойства элемента, в то время как Структурные директивы
    изменяют макет DOM путем добавления и удаления элементов DOM

    Структурные директивы (Structural Directives):
    ngIf:

    Используется для условного отображения элемента на основе значения выражения.
    html
    Copy code
    <div *ngIf="isLoggedIn">
      Добро пожаловать, {{ username }}!
    </div>
    ngFor:

    Используется для отображения списка элементов.
    html
    Copy code
    <ul>
      <li *ngFor="let item of items">{{ item }}</li>
    </ul>
    ngSwitch:

    Используется для условного отображения содержимого в зависимости от значения.
    html
    Copy code
    <div [ngSwitch]="color">
      <div *ngSwitchCase="'red'">Красный</div>
      <div *ngSwitchCase="'blue'">Синий</div>
      <div *ngSwitchDefault>Другой цвет</div>
    </div>


    Шаблонные директивы (Attribute Directives):
    ngStyle:

    Используется для динамического применения стилей к элементу.
    html
    Copy code
    <div [ngStyle]="{'color': textColor, 'font-size': fontSize}">
      Текст с динамическими стилями
    </div>
    ngClass:

    Используется для динамического применения классов к элементу.
    html
    Copy code
    <div [ngClass]="{'active': isActive, 'highlight': isHighlighted}">
      Элемент с динамическими классами
    </div>
    ngModel:

    Используется для связывания двустороннего ввода с данными модели.
    html
    Copy code
    <input [(ngModel)]="username" />
    Это всего лишь несколько примеров директив в Angular. Обычные директивы, такие как *ngIf, *ngFor, и *ngSwitch, предоставляют мощные инструменты для управления структурой DOM на основе условий и данных. Структурные директивы, такие как ngStyle, ngClass и ngModel, позволяют динамически изменять стили, классы и взаимодействие с формами.`,
    },
    {
      title: 'Директивы кастомные',
      quest: `

      Директивы добавляем в declarations модуля или импорт

      Создание структурной директивы:

      <div *colory="true" ></div>

      @Directive({
        selector: '[colory]',
      })
      export class ColoryDirective {

        @Input() colory:any

        template = inject(TemplateRef) // Элемент, к которому добавляется атрибут colory
        view = inject(ViewContainerRef) // Обертка ng-template, в которую ангуляр оборачивает

        ngOnInit() {
          this.colory && this.view.createEmbeddedView(this.template) // Добавляем в ngContent на элемент, есил инпут равен true
        }
      }

      Создание атрибутной директивы:

      <div colory="blue" #controller="colorController">awdwadwadaw</div>
      <button (click)="controller.controllerClicked()" ></button>

      @Directive({
        selector: '[colory]',
        exportAs: 'colorController', // Вызываем контроллер директивы из шаблона по этому названию
      })
      export class ColoryDirective {
        @Input() colory: any; //Принимаем в шаблоне аргумент
        @HostBinding('style.color') color = 'red'; // Изменение свойст хоста

        @HostListener('click') clicked = () => {
          this.color = this.colory; // Меняем цвет через прослушивание событий на хосте
        };

        controllerClicked() {
          this.color = 'green';
        } // Меняем цвет через контролле в шаблоне
      }



      `,
    },
    {
      title: 'Динамические компоненты в ангуляр',
      quest: `

    Пример создания

    @Component({
      selector: 'app-dynamic',
      template: "{{name}}",

    })
    export class DynamicComponent {
      @Input() name!: string
    }

    @Component({
      selector: 'app-root',
      standalone: true,
      imports: [CommonModule, RouterModule, ReactiveFormsModule],
      template: "
        <button class="show-btn" (click)="createComponent()">Clear</button>
      <button class="remove-btn" (click)="removeComponent()">Remove</button>
      <ng-container #container></ng-container>
      ",
    })
    export class AppComponent {
      bool = true
      @ViewChild('container', { read: ViewContainerRef })
      private container!: ViewContainerRef;

      createComponent(): void {
        this.container.clear(); // Очищает template
        const component = this.container.createComponent(DynamicComponent);//Создаем новый компонент
        component.instance.name = 'Игорь' // Передача данных
      }
      removeComponent(): void {
        this.container.clear(); // Удаляем динамический компонент
      }
    }



    `,
    },
  ];
  PRINCIPS = [
    {
      title: 'Принципы ООП',
      quest: `

      1.Инкапсуляция:
      Принцип: Сокрытие данных внутри объекта.
      Предоставление доступа к ним через функции. Например геттеры и сеттеры

      2. Наследование:
      Принцип: Создание новых классов на основе существующих.
      Это помогает переиспользовать существующий код

      3.Полиморфизм:
      Принцип: Объекты разных типов могут использовать одинаковые методы.
      Суть полиморфизма заключается в том, что мы переопределяем метод у
      наследующегося класса и можем обратиться к этому методу и получить другой результат

      4.Абстракция:
      Принцип: Создание упрощенных моделей объектов.
      Базовый класс содержит методы и свойства, которые должны быть у всех наследующих классов.

      class Transport {
        constructor(type) {
            this.type = type;
        }

        start() {
            console.log($this.type is starting);
        }

        stop() {
            console.log(this.type is stopping);
        }
    }

    // Конкретная реализация абстракции
    class Car extends Transport {
        constructor(make, model) {
            super('Car');
            this.make = make;
            this.model = model;
        }

        drive() {
            console.log(this.make this.model is driving);
        }
    }

    // Конкретная реализация абстракции
    class Bicycle extends Transport {
        constructor(brand) {
            super('Bicycle');
            this.brand = brand;
        }

        pedal() {
            console.log(this.brand bicycle is pedaling);
        }
    }

    // Использование абстракции
    const myCar = new Car('Toyota', 'Camry');
    const myBicycle = new Bicycle('Schwinn');

    myCar.start();      // Выводит "Car is starting"
    myCar.drive();      // Выводит "Toyota Camry is driving"
    myCar.stop();       // Выводит "Car is stopping"

    myBicycle.start();  // Выводит "Bicycle is starting"
    myBicycle.pedal();  // Выводит "Schwinn bicycle is pedaling"
    myBicycle.stop();   // Выводит "Bicycle is stopping"
    В этом примере абстракция Transport предоставляет общий интерфейс для всех видов транспорта, а конкретные реализации, такие как Car и Bicycle, предоставляют специфичные для них методы. Это позволяет использовать объекты разных типов с единым интерфейсом.
      `,
    },
    {
      title: 'REST Api принципы',
      quest: `
    REST API представляет собой набор правил для взаимодействия клиента и сервера.
    То есть стандарт.

    Ресурсы:

    Принцип: Информация представляется в виде ресурсов с уникальными идентификаторами (URI).
    Пример: /users/123 представляет ресурс пользователя с идентификатором 123.
    Унификация интерфейса:

    Принцип: Использование стандартных HTTP-методов (GET, POST, PUT, DELETE) для взаимодействия с ресурсами.
    Пример: GET /users для получения списка пользователей.
    Без состояния:

    Принцип: Каждый запрос содержит всю необходимую информацию, и сервер не хранит состояние между запросами.
    Пример: Сессионные данные хранятся на клиенте, а не на сервере.
    Представление ресурсов:

    Принцип: Ресурсы могут иметь различные представления (JSON, XML), и клиенты выбирают подходящее.
    Пример: Accept: application/json в заголовке запроса для запроса JSON-представления ресурса.
    Система кэширования:

    Принцип: Используется кэширование для повышения производительности и снижения нагрузки на сервер.
    Пример: Cache-Control: max-age=3600 в заголовке для кэширования ресурса на 1 час.
    `,
    },
    {
      title: 'SOLID принципы',
      quest: `
      Принципы SOLID это принципы, которые выведены  для обеспечения гибкости, поддержки и удобства расширения приложений.

      1.Принцип единственной ответственности (Single Responsibility Principle - SRP):
      Каждый класс должен иметь только одну причину для изменения. В других словах, класс должен быть ответствен только за одну важную часть
      функциональности.
      Наприме, у нас есть API сервис, который может только лишб делать запросы и отдавать данные. Если он будет еще и как то обрабатывать эти данные,
      то принцип нарушается.

      2.Принцип открытости/закрытости (Open/Closed Principle - OCP):
      Программные сущности (классы, модули, функции и т. д.) должны быть открытыми для расширения, но закрытыми для модификации.
      Это означает, что можно добавлять новую функциональность, не изменяя существующий код.

      // Плохо: Нарушение OCP
      class VoiseService {

        getVoise(type: string): string {
          if (type === 'dog') {
            return 'GAV';
          } else if (type === 'cat') {
            return 'MIU';
          }
        }
      }

      А тут мы создаем классы для каждго случая и определяем методы. И передаем эти классы вместо type


      class dogVoise implements Animal {
        getVoise(): string {
          return 'GAV';
        }
      }

      class catVoise implements Animal {
        getVoise(): string {
          return 'MIU';
        }
      }

      class TransportHandlerService {
        private animal: Animal;

        constructor(animal: Animal) {
          this.animal = animal;
        }

        getVoice(): string {
          return this.animal.getVoice();
        }
      }

      3.Третий принцип подстановки Лисков:
      Принцип: Объекты базового класса должны быть заменяемыми объектами производного класса без изменения корректности программы.
      Интерпретация:
      Если у вас есть класс S и класс T, и T является подклассом S, то объекты типа S могут быть заменены
      объектами типа T без нарушения функциональности программы.
      Иными словами, код, написанный для базового класса, должен корректно работать с объектами производного класса, не зная об этом.
      Это обеспечивает поддержание подтипов и гарантирует, что замена объектов не нарушит корректность программы.

      4.Принцип разделения интерфейса (Interface Segregation Principle - ISP):
      Клиенты не должны зависеть от интерфейсов, которые они не используют. Это означает, что не следует заставлять клиентов реализовывать методы,
      которые им не нужны.

      Пример: интерфейсы жизненных циклов компонента. Если нам нужен только интерфейс ngOnInit, то мы имплементруемся только от него, а не от всех
      И нам не нужно реализовывать все методы жизненного цикла

      5.Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
      Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. Кроме того,
      абстракции не должны зависеть от деталей.
      Это подразумевает использование интерфейсов или абстрактных классов для связи между модулями.
      Утверждает, что сущности (классы, модули) не должны зависеть от конкретных реализаций, а и сущности и реализации
      должны зависеть от абстракций.

      Пример: DI в ангуляр. Когда нам нужен какой то сервис, мы передаем его через конструктор, и указываем интерфейс в качестве зависимости,
      а не от реализации. Мы можем в любой момент подменить реализацию, главное чтобы она соответствовала требованиям интерфейса.
      Это облегчает тестируемость класса.


    `,
    },
  ];
  themes = {
    CSS: this.CSS,
    JS: this.JS,
    TS: this.TS,
    RXJS: this.RXJS,
    ANGULAR: this.ANGULAR,
    PRINCIPS: this.PRINCIPS,
    BROWSER: this.BROWSER,
  };
}
