import { Injectable } from '@angular/core';
interface Quest {
  title: string;
  quest: string;
}

type QuestsArr = Quest[];

@Injectable({
  providedIn: 'root',
})
export class ThemesService {
  HRQuestions: QuestsArr = [
    {
      title: 'Про архитектуру приложения на прошлой работе',
      quest: `
      Во первых, у нас стандартная NX архитектура. NX пропогандирует такую архитектуру, что приложение у нас
      по сути является неким большим контейнером для множества библиотек, из которых
      оно и будет состоять. То есть у нас в папке APP находится 10 процентов кода,
      а остальное у нас находится в папке LIBS.
      В LIBS у нас есть папка CORE, где хранятся библиотеки, которые являются общими для всех приложений.
      И на этом же уровне есть папки с названиями наших приложений, где уже хранятся либы для наших конкретных приложений.
      И в каждой такой папке есть своя папка CORE, где хранятся либы, которые общие для всего приложений.
      И получается, что мы придерживаемся фрактальной архитектуры получается - это когда малые части большого целого полностью повторяют большое целое.
      Еще мы взяли что то от архитектуры Домейн Дривен Дизайн "DDD",
      Мы разделяем приложение на какие то доменные области. И каждая область у нас по сути является отдельным мини-приложением.
      Допустим у нас есть доменная область "Статьи". Это будет отдельная фича с одной или несколькими либами. У нас есть несколько видов либ.
      FEATURE - законченная часть какого то функционала или какой то доменной области.
      DATA-ACCESS - отвечает за хранение данных и их менеджмент.
      UI - отвечает уже за отображение.
      UTILS - какие то мелкие инструменты, которые нам пригождаются.


      В общем CORE у нас например может находиться фича с регистрацией и авторизацией, если оно нам нужно во всех приложения.

      `,
    },
  ];
  OTHER: QuestsArr = [
    {
      title: 'Паттерны',
      quest: `
      Adapter: Позволяет объектам с несовместимыми интерфейсами взаимодействовать. Используется, когда требуется сделать
      существующий класс совместимым с интерфейсом, который вы ожидаете.

      Dependency Injection: Позволяет внедрять зависимости в объекты вместо того, чтобы создавать их внутри объекта.
      Это способствует более слабой связанности и повышает тестируемость.

      Фасад (Facade):  цель в том, чтобы скрыть сложность взаимодействия с определенной подсистемой,
      предоставив более простой интерфейс для клиента. Если говорить проще, то Facade это альтернатива умным компонентам.
      То есть там делается обращение к ngrx.

      Паттерн Singleton(синглтон) - это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр,
      и предоставляет глобальную точку доступа к этому экземпляру.

      Шаблон проектирования "smart-dumb компоненты"  - Преимущества использования этого шаблона:

      Разделение обязанностей: Разделяя компоненты на "умные" и "глупые", вы создаете более модульный и понятный код, где каждая часть отвечает только за свою конкретную задачу.
      Легче тестирование: Поскольку умные компоненты содержат бизнес-логику, их можно более эффективно тестировать, а глупые компоненты могут быть протестированы с использованием простых снимков (snapshots) или сравнения отображения.
      Повторное использование кода: Глупые компоненты могут быть повторно использованы в разных местах вашего приложения, так как они полностью независимы от контекста.

      Декоратор - это шаблон проектирования, который представляет собой структурный шаблон проектирования.
      Он используется для динамического добавления нового функционала объектам без изменения их основной структуры.

      Паттерн Фабрика — это способ создания объектов, при котором мы делегируем процесс создания конкретных объектов
      отдельной "фабрике". Эта фабрика может иметь несколько реализаций, каждая из которых создает объекты определенного типа.
      Допустим, у нас есть сервис, у которого есть метод, который принимает аргумент и в зависимости от него создает и возвращает
      либо один класс, либо другой. Мы инжектируем этот сервис и уже вызывааем метод внутри компонента или сервиса.

      `,
    },
    {
      title: 'Что такое NX',
      quest: `
      В основе NX лежат схематики для генерации кода и различные конфигурации которые позволяют управлять сразу
      сотнями проектов. Например у нас есть один репозиторий, где есть 100 проектов на ангуляре. И если мы хотим чтобы на всех
      проектах была олна версия ангуляра, то мы можем поменять разом у всех проектов версию ангуляра. Или Тайпрскрипта.
      У на есть файл NX.json, где полностью описываетсяч структура приложения

      Сама философия NX заключается в том, что приложение является чисто контейнером для библиотек, а практически весь код сам находится
      в библиотеках и поэтому мы можем любой код, который мы пишеми, можем взять и переиспользовать в другом проекте.
      `,
    },
    {
      title: 'Работа с WebSocket ',
      quest: `

      WebSocket - это протокол передачи данных, предназначенный для обеспечения двусторонней связи между
      веб-браузерами и веб-серверами в режиме реального времени. Когда кто то отправляет какой то сообщение на сервер, оно
      отправляется всем подключенным подписчикам к серверу. Это можно представить как подписку.

      Пример:

      const socket = new WebSocket('ws://localhost:3000');


      // Обработка события открытия соединения
      socket.onopen = (event) => {
        console.log('Соединение установлено');//Выведется при успешном подключении  серверу

        socket.send('Эфенди подключился');//Отправляем сообщение на сервер
      };

      // Обработка события получения сообщения от сервера
      socket.onmessage = (event) => {
        console.log(event.data);//Получаем сообщение: 'Эфенди подключился'
      };

      // Обработка события закрытия соединения
      socket.onclose = (event) => {
        console.log('Соединение закрыто');
      };

      // Обработка события ошибки
      socket.onerror = (error) => {
        console.error(Произошла ошибка: .message);
      };

        `,
    },
    {
      title: 'Как загрузить скрипт JS после загрузки сраницы? ASYNC DEFFER ',
      quest: `
        1. Написать <script></script> перед закрывающим тегом body/ В таком случае скрипт начнет загрузку только
        после
        `,
    },
    {
      title: 'DOM, VIRTUAL DOM, INCREMENTAL DOM',
      quest: `
      Реальный DOM - это представление структуры веб-страницы в браузере, доступное для манипуляций с использованием JavaScript
      Когда браузер загружает веб-страницу, он строит реальный DOM на основе HTML-кода страницы. Этот процесс называется парсингом.
      Реальный DOM может быть изменен с использованием JavaScript, что позволяет динамически изменять содержимое и структуру веб-страницы
      в ответ на пользовательские действия или другие события.
      Однако манипуляции с реальным DOM могут быть ресурсозатратными, особенно при интенсивном обновлении.
      Вот почему был создан подход с виртуальным DOM,

      VIRTUAL DOM - это легковесная абстрактная копия реального DOM, которая создается и обновляется во время работы приложения.
      Процесс работы с виртуальным DOM обычно выглядит следующим образом:

      1. При изменении состояния или свойств компонента, библиотека создает новое виртуальное дерево DOM, которое представляет обновленное состояние интерфейса.

      2. Затем сравнивается новое виртуальное дерево DOM с предыдущим (старым) виртуальным деревом DOM, чтобы выяснить, какие элементы изменились.

      3. После сравнения, библиотека определяет минимальное количество операций, необходимых для обновления реального DOM, выполняет эти операция,
      перерисовав только измененные части DOM


      Incremental DOM - это не структура данных или сущность, как виртуальный DOM, а всего лишь подход или методика
      обновления DOM, при котором изменения применяются напрямую к реальному DOM без предварительного создания полного виртуального дерева
      Вот как Angular обновляет DOM:

      1. Angular использует механизм (Zone.js) для отслеживания изменений и запуска обнаружения изменений (change detection)
      для проверки обновлений в шаблоне компонента.

      2. Во время обнаружения изменений Angular проходит по компонентам и обновляет только изменившиеся части реального DOM.




      `,
    },
    {
      title: 'Что такое BOM? ',
      quest: `
      BOM или (Browser Object Model — объектная модель браузера) позволяет JavaScript взаимодействовать с браузером.
       Данная модель включает в себя такие объекты, как navigator, location, history, screen, XMLHttpRequest и т.п.
       Другими словами, BOM — это дополнительные объекты, предоставляемые браузером, чтобы работать со всем, кроме документа.
      Обратите внимание: BOM не стандартизирована, поэтому ее реализация может отличаться в разных браузерах.
      `,
    },
    {
      title: 'CORS  ',
      quest: `
      CORS - это механизм, который запрещает обращение к серверу с какого то домена. То есть чтобы мы могли обратиться с какого то домена к серверу, сервер
      должен нам разрешить это сделать. Когда веб-страница пытается сделать кроссдоменный запрос, браузер отправляет предварительный запрос
      на сервер, чтобы узнать, разрешены ли запросы с этого домена.
      Если веб-страница пытается сделать запрос к ресурсу с другого домена, браузер добавляет в запрос дополнительные заголовки, такие как Origin.
      Это инициирует механизм CORS и приводит к выполнению предварительного запроса, который отправляется методом OPTIONS для проверки,
      разрешены ли запросы от данного домена. Если сервер разрешает, браузер отправляет основной запрос. Чтобы разрешить кроссдоменные запросы к серверу,
      сервер должен включить в ответ специальные заголовки CORS. Один из основных заголовков
      - это Access-Control-Allow-Origin, который указывает, каким доменам разрешено делать запросы к ресурсам на сервере.
      (например, Access-Control-Allow-Origin: https://ваш-домен.com)


      Домены могут отличаться по протоколу HTTP, HTTPS,
      По домену: example1.com, example2.com
      По порту: localhost:4200, localhost:4201
      По регистрации домена: x.com, x.net

      То есть, если у нас сервер разрешает обращение только с домена HTTP://x.com, то с HTTPS://x.com мы обратиться не сможем.

      Если CORS не применяется, то любой сайт(мошеннический), который вы посещаете, мог бы выполнять JavaScript-код, который делает запросы
      к другим ресурсам от вашего имени без вашего ведома.
      Это может включать в себя запросы к социальным сетям, банковским сайтам или другим сервисам, где у вас есть активная сессия.
      С CORS серверы имеют возможность указывать, каким доменам разрешено делать запросы. Это добавляет слой безопасности,
      предотвращая потенциально вредные запросы от несанкционированных источников.

      `,
    },
  ];
  BROWSER: QuestsArr = [
    {
      title: 'Что такое COORS? ',
      quest: `
      Что такое CORS?

      Cross-Origin Resource Sharing (CORS) - это стандарт безопасности в браузерах, который контролирует, как веб-сайты могут
      делать запросы к ресурсам (например, получать данные) с других доменов (origin).
      Зачем это нужно?

      CORS существует для предотвращения возможных угроз безопасности, связанных с тем, что веб-страницы могут делать запросы
      к другим доменам без разрешения.

      Проблема:
      Если ваш веб-сайт (например, example.com) пытается получить данные с другого веб-сайта (например, api.com),
      браузер может заблокировать запрос из-за политики безопасности.

      Решение:
      Владелец api.com должен настроить свой сервер так, чтобы он "разрешил" запросы от example.com. Это делается
      с помощью специальных HTTP-заголовков.

      Как это сделать:
      На стороне сервера api.com должен отправить заголовок Access-Control-Allow-Origin, указывая, каким доменам разрешено
      делать запросы. Например, Access-Control-Allow-Origin: http://example.com разрешит запросы от example.com.
      Или же он может указать "*", что говорит о том, что запрос разрешен любому сайту.

      Как проходит процесс:
      Браузер обнаруживает потенциально блокирующий запрос CORS:

      Когда браузер обнаруживает, что запрос может быть блокирован политикой CORS (например, из-за использования кастомных заголовков или методов), он инициирует процесс предварительного запроса.

      Предварительный запрос (Preflight Request):
      Браузер отправляет предварительный запрос типа OPTIONS на сервер с дополнительной информацией о намерениях основного запроса.
      Запрос Options содержит в себе заголовок origin: site.com - сайт с которого делает запрос
      Если запрос разрешен, сервер возвращает ответ с заголовками:
      Access-Control-Allow-Origin: site.com
      Access-Control-Allow-Methods: "PUT".
      Это будет значит, что сайту site.com разрешено делать PUT запрос к этому серверу и браузер его отправит.

      Если сервер не разрешает запрос, то такого заголовка в ответе не будет,
      браузер сгенерирует CORS ошибку и вернет ее, не делач запроса к серверу.

      Заголовок Access-Control-Allow-Origin может содержать * (звездочку) в значении, что означает "любой источник".
      Установка этого заголовка на * позволяет любому домену отправлять запросы к вашему серверу без ограничений на стороне браузера.

      `,
    },
    {
      title: 'Все про HTTP/HTTPS ',
      quest: `
      Протокол передачи данных:

      HTTP (HyperText Transfer Protocol): Это протокол передачи данных между клиентом и сервером в незашифрованном виде.

      HTTPS Это защищенная версия HTTP

      HTTP запрос сотоит из URL, BODY, HEADERS, METHOD

      `,
    },
    {
      title:
        'Как браузер загружает html / critical rendering path / критический путь рендеринга',
      quest: `
      Запрос на сервер:
      Браузер отправляет HTTP-запрос на сервер по введенному пользователем URL.

      Получение HTML:
      Сервер отправляет HTML-код в ответ на запрос браузера.

      Далее происходит:

      1 Парсинг и создание DOM(объектная модлель документа):
        Браузер парсит(анализирует) HTML, создает DOM - древовидное представление структуры документа.

      2 Построение CSSOM:
        Браузер строит CSSOM (CSS Object Model).
        Когда браузер сталкивается с тегом <link> или стилями внутри тега <style>, он начинает загрузку и парсинг CSS-файлов.
        Парсинг CSSOM происходит пареллельно с парсингом DOM

      3 Запуск JavaScript:
        JavaScript является блокирующим ресурсом для парсера. Это означает, что JavaScript по умолчанию
        блокирует разбор самого HTML-документа.

      4 Создание Render Tree(рендер дерева):
        DOM и CSSOM объединяются в Render Tree, представляющий структуру отображения элементов.

      5 Расчет макета:
        Браузер определяет размеры и расположение элементов на странице (Layout).

      6 Отрисовка и отображение:
        Происходит отрисовка

      Про JS:
          Загрузка JS скрипта по умолчанию блокирует парсинг HTML. Когда браузер встречает тег <script>
          без атрибутов async или defer, он приостанавливает парсинг HTML, загружает и выполняет JS-скрипт,
          а затем продолжает парсинг HTML.

          Без атрибутов async и defer:
          Браузер приостанавливает парсинг HTML.
          Загружается и выполняется JS-скрипт.
          После выполнения JS-скрипта продолжается парсинг HTML.

          С атрибутом async:
          Загрузка и выполнение JS-скрипта происходит асинхронно, не блокируя парсинг HTML.
          JS-скрипт выполнится сразу после загрузки, когда станет доступен.

          С атрибутом defer:
          Загрузка JS-скрипта также происходит асинхронно, но выполнение откладывается до завершения парсинга HTML.
          JS-скрипт будет выполнен в том порядке, в котором он появляется в HTML-документе.

      Парсинг JS:
          Хорошая новость, касательно HTML, заключается в том, что он может быть исполнен по частям.
          Документ не должен быть загружен полностью для того, чтобы контент начал появляться на странице.
          Однако, другие ресурсы, такие как CSS и JavaScript, могут блокировать отрисовку страницы.

      Парсинг CSS:
          CSS считается «блокирующим обработку ресурсом». Это значит, что Render-дерево (см. ниже)
          не может быть построено без полного первоначального разбора CSS.
          В отличии от HTML, CSS не может быть использован по частям в силу своей каскадной природы.
          Стили, описанные в документе ниже, могут переопределять и изменять стили, определённые ранее.
          Так что если мы начнём использовать CSS-стили до того, как будет разобрана таблица стилей, мы можем
          столкнуться с ситуацией, когда стили будут применяться неверно. Это означает, что для перехода к следующему шагу,
          необходимо полностью разобрать CSS.
      `,
    },
    {
      title: 'Что происходит, когда мы вводим url в строку браузера',
      quest: `
      1. Браузер ищет IP сервера в локальном кэше, история браузера, в ОС. кэше  роутера и т.д
      2. Браузер отправляет запрос к DNS-серверам, чтобы получить IP сервера
      3. Браузер после получения IP устанавливает TCP соединение с этим сервером
      4. Браузер отправляет HTTP-запрос, чтобы получить контент сайта
      5. Сервер обрабатывает запрос
      6. Сервер отправляет ответ браузеру
      7. Браузер обрабатывает полученный ответ
      `,
    },
  ];
  CSS: QuestsArr = [
    {
      title: 'Приемущества и отличия SCSS',
      quest: `

     1. Удобные переменные:

    scss:

    $size: 100px

    div{
      font-size: $size
    }

    css:

    --size: #100px;

    div{
      font-size: var(--size)

    }



    2. Миксины:
    @mixin button-styles {
      padding: 10px;
      border: 1px solid #ccc;
    }
    .my-button {
      @include button-styles;
      color: #333;
    }

    3.Вложенность
    .user{
      color: blue
      p{
        color:  black
      }
      &-card{
        color: green
      }
      &:hover{
        color: red
      }

    }

    4.Функции
    @function calculate-width($width, $multiplier) {
      @return $width * $multiplier;
    }
    .element {
      width: calculate-width(100px, 2);
    }

    5.Шаблоны
    %button-styles {
      padding: 10px;
      border: 1px solid #ccc;
      background-color: #f0f0f0;
    }
    .my-button {
      @extend %button-styles;
      color: #333;
    }

    6. Математические операции
    scss:
    div{
      font-size: 100% - 30px
    }
    css:
    div{
      font-size: calc(100%-30px)
    }

    7. Import:
    @import "./"


    `,
    },
    {
      title: 'Анимации css',
      quest: `

      CSS Transitions:

                    .box {
                      width: 100px;
                      height: 100px;
                      background-color: red;
                      transition: width 1s ease-in-out;
                      }

                      .box:hover {
                          width: 200px;
                      }

        CSS Animations:


                        @keyframes example {
                          from {
                              width: 100px;
                          }
                          to {
                              width: 200px;
                          }
                      }

                      .box {
                          width: 100px;
                          height: 100px;
                          background-color: red;
                          animation: example 2s ease-in-out infinite alternate;
                      }


      CSS Transforms:
                    transform: Позволяет применять трансформации, такие как смещение, вращение, масштабирование и т. д.
                    .box {
                      width: 100px;
                      height: 100px;
                      background-color: red;
                      transition: transform 1s ease-in-out;
                  }

                  .box:hover {
                      transform: scale(1.5);
                  }


      `,
    },
    {
      title: 'Единицы измерения (px, vh и тд)',
      quest: `
        10vh - 10% высоты экрана.
        10vw - 10% ширины экрана.
        1em - размер шрифта текущего элемента. То есть 1em = 100%
        1rem (root em) - размер шрифта размера шрифта корневого (html) элемента
        10px - 10 пикселей.
      `,
    },
    {
      title: 'Position',
      quest: `
      static
      Это значение позволяет элементу находиться в обычном его состоянии, расположенном на своём месте в документе. Свойства top, right, bottom, left и z-index не применяются к данному элементу.
      Это значение по умолчанию.

      relative
      Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно себя на основе значений top, right, bottom и left.

      absolute
      Элемент удаляется из обычного потока документа, и для элемента в макете страницы не выделяется дополнительное пространство.
      Он располагается относительно своего ближайшего спозиционированного предка, если такой есть; в противном случае он помещается
      относительно исходного содержащего блока.
      Его конечная позиция определяется значениями top, right, bottom, и left


      fixed
      Элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство.
      Он позиционируется относительно исходного браузерного окна

      sticky
      Кратко ... Элемент с position: sticky «прилипает» к экрану при прокрутке, пока не встретится с границей родительского блока

    `,
    },
    {
      title: 'Селекторы',
      quest: `

      Приоритет селекторов:
      Если мы пользуемся !important, то он имеет наивыысший пиоритет.
      1. Инлайн стили
      2. селекторы по ID
      3. селекторы по классу
      4. селекторы по тегу

      При одинаковой силе последний селектор перезатирает свойства предыдущих.
      Но селектор .class1 .class2 сильнее чем просто .class2

      .class1 .class2 {} = Этот селектор выбирает все элементы с классом .class2, которые вложены в элементы с классом .class1.
      .class1 > .class2 {} =  Этот селектор выбирает все элементы с классом .class2, которые являются (прямыми потомками) элементов с классом .class1.
      .class1.class2 {} =  Это означает, что вы выбираете элемент, который имеет оба указанных класса. У элемента должны одновременно присутствовать оба класса для того, чтобы селектор сработал.
      .class1, .class2 {} = Этот селектор будет содержать общие классы для обоих классов. Они применяется и к class1 и к class2
      .class1[attribut] {} = Этот стиль применится к элементам с классом .class1, у которых есть атрибут attribut.
      .class1:not(.class2) {} = Этот стиль применится к элементам с классом .class1, но не имеющим класс .class2.
      .class1 + .class2 {} = Этот стиль применится к элементам с классом .class2, которые непосредственно следуют за элементами с классом .class1.
      .class1 ~ .class2 {} = Применится к элементам с классом .class2, которые идут после элементов с классом .class1 на том же уровне вложенности.


    `,
    },
  ];
  HTTP: QuestsArr = [
    {
      title: 'REST принципы',
      quest: `
    Принципы работы REST API
    Технология работает на базе семи принципах, один из которых является опциональным. Прежде, чем начать их описывать, уточним, что в вебе ресурсом называют любые данные: текстовые, графические (изображения, видео), звуковые (аудио), программные (целые приложения).

    Клиент-серверная модель (Client-Server)
    Клиентом может быть человек или программная исистема, которая использует API. Например, пользовательский интерфейс сайта. В REST API коды запросов остаются на клиентской стороне, а коды доступа к ресурсам — на сервере. Это облегчает работу API, перенос пользовательского интерфейса на другие платформы, улучшает масштабирование серверного хранения данных.

    Отсутствие состояния (Stateless)
    Серверы не должны хранить записи о состоянии (или о выполненных операциях) клиентов. Все клиентские запросы должны содержать только те сведения, которые нужны, чтобы получить данные от серверов.

    Кэширование (Casheable)
    Кэширование — процесс сохранение данных с сервера в буфере на случай частых обращениях к нему. При наличии такого указания в запросе REST API клиенты получают право быстрого обращения к буферу с сохраненными данными, что способствует снижению нагрузки на систему — нужная информация загружается быстро.

    Единообразие интерфейса (Uniform Interface)
    Запрос на получение данных должен осуществляться посредством одного URL-адреса с помощью стандартных протоколов, таких как HTTP. Это делает архитектуру сайтов или приложений максимально простой и облегчает взаимодействие с серверами.

    Многоуровневая система (Layered System)
    RESTful имеет многоуровневую системную архитектуру, при которой клиенты могут подключаться к остальным посредникам и получать необходимые ответы с серверов. Серверы также могут передавать запросы другим серверам. Благодаря этому можно спроектировать веб-службу REST API для работы с несколькими серверами на нескольких уровнях (с разной безопасностью, приложениями, бизнес-логикой), причем эти уровни будут оставаться невидимыми для клиентов.

    Код по требованию (Code on Demand)
    В архитектуре REST сервер может на время расширить или настроить функциональные возможности клиентов, передав код программы. Так, при неправильном заполнении регистрационной формы на сайте веб-браузер выделит допущенную ошибку благодаря коду, отправленному сервером.

    Начало от нуля (Starting with the Null Style)
    Все клиентские запросы к серверу проходят через одну точку входа. Все дальнейшее взаимодействие обеспечивается самими серверами.

    `,
    },
    {
      title: 'Из чего состоит запрос',
      quest: `

      Метод запроса (Request Method): Это определяет тип операции, которую нужно выполнить. Например, GET, POST, PUT, DELETE и так далее.

      URI (Uniform Resource Identifier): Это идентификатор ресурса, к которому вы обращаетесь. Это может быть адрес веб-страницы, API-ресурса или любого другого ресурса в сети.

      Версия протокола (HTTP Protocol Version): Это указывает на используемую версию HTTP. Например, HTTP/1.1.

      Заголовки (Headers): Заголовки содержат метаданные запроса, такие как тип контента, язык, формат ответа и другие. Примеры заголовков включают Content-Type, Accept, Authorization и т.д.

      Тело запроса (Request Body): Это необязательная часть, которая используется для передачи данных в запросе. Например, при отправке данных формы или JSON-объекта на сервер.
      Если это POST-запрос с телом запроса (например, отправка данных формы или JSON), он может выглядеть так:

      http
      Copy code
      POST /api/create HTTP/1.1
      Host: example.com
      Content-Type: application/json
      Content-Length: 52

      {
        "name": "John Doe",
        "age": 30
      }

    `,
    },
    {
      title: 'JWT токены',
      quest: `
    Процесс обновления токенов (refresh token и access token) в системе аутентификации работает следующим образом:

    Выдача токенов: При успешной аутентификации (обычно с использованием логина и пароля, аутентификационных токенов или других методов), сервер аутентификации выдает два основных вида токенов - access token (токен доступа) и refresh token (токен обновления). Access token используется для получения доступа к ресурсам, а refresh token служит для обновления access token без повторной аутентификации пользователя.

    Хранение токенов: Оба токена обычно хранятся в безопасном месте на клиентской стороне. Access token обычно имеет короткий срок действия для обеспечения безопасности, в то время как refresh token имеет более долгий срок действия.

    Использование access token: Когда клиент делает запрос к защищенным ресурсам (например, API), он предоставляет access token в заголовке запроса или в теле запроса. Сервер проверяет валидность access token и предоставляет доступ к ресурсам, если токен действителен.

    Истечение срока действия access token: Если access token истекает, клиент должен запросить новый токен. Вместо того, чтобы просить пользователя ввести учетные данные снова, используется refresh token для получения нового access token.

    Обновление access token с использованием refresh token: Когда access token истекает, клиент отправляет запрос на обновление токена, предоставив refresh token. Запрос направляется к серверу аутентификации, который проверяет валидность refresh token. Если refresh token действителен, сервер аутентификации выдает новый access token.

    Процесс обновления токенов обеспечивает баланс между безопасностью (частое обновление access token) и удобством для пользователя (предотвращение частой необходимости повторной аутентификации).

    `,
    },
  ];
  JS: QuestsArr = [
    {
      title: 'Функуии генераторы JS',
      quest: `Функции генераторы это функции, которые возвращают итератор, который позволяет получать значения по одному.

       function * gen(){
              yield 1;
              yield 2;
              return 3;
            }

        gen().next() // {value: 1, done: false}
        gen().next() // {value: 2, done: false}
        gen().next() // {value: 3, done: true}
        gen().next() // {value: undefined, done: true}

        // value - значение, которое возвращает итератор
        // done - признак завершения итератора

      Так же функция-генератор является итерируемымми объектами

      for(let value of gen) {
        alert(value); // 1, затем 2. return не учитывается
      }

      [...gen] // [1, 2]


      Так же возможна композиция генераторов

       function * gen1(){
              yield 1;
              yield 2;
              return 3;
            }

       function * gen2(){
              yield 0;
              yield* gen1();
              yield 4;
            }

        [...gen2] // [0, 1, 2, 3, 4]

      `,
    },
    {
      title: 'Операторы ?? && ||',
      quest: `
    (&&) возвращает либо первое ложное значение, либо любое последнее
    (||) возвращает либо первое истинное значение, либо любое последнее
    (??) возвращает любое первое значение(даже 0, false и тд), которое не равно null или undefined, либо любое последнее
    `,
    },
    {
      title: 'Babel, полифилы в JS',
      quest: `
      Babel - это инструмент для транспиляции кода на JavaScript из одной версии стандарта ECMAScript в другую. ECMAScript - это стандарт, на котором основан JavaScript. Когда новые версии ECMAScript выпускаются, не все браузеры и среды выполнения поддерживают их сразу. Babel помогает разработчикам писать код на более новых версиях ECMAScript и затем преобразовывать его в код, который может быть выполнен на старых версиях.
      Babel может включать в себя полифилы (polyfills) в зависимости от того, как он настроен и какие плагины вы используете. Полифилы - это куски кода, предназначенные для реализации функциональности, которая отсутствует или не полностью поддерживается в определенной среде выполнения.
      Например, если вы используете Babel для преобразования кода, написанного с использованием новых методов или функций, которые могут отсутствовать в старых версиях браузеров, Babel может добавить соответствующие полифилы в выходной код.
`,
    },
    {
      title: 'Date в JS',
      quest: `

    Объект Date в JavaScript предоставляет возможности для работы с датами и временем.
    Вот некоторые основные методы и свойства объекта Date:
    new Date(); // Mon Jan 15 2024 12:13:01 GMT+0300 (Москва, стандартное время) {}
    Основные методы:

    getHours(), getMinutes(), getSeconds(): Получение часов, минут и секунд соответственно.

    setHours(), setMinutes(), setSeconds(): Установка часов, минут и секунд соответственно.

    getFullYear(), getMonth(), getDate(): Получение года, месяца (от 0 до 11) и дня месяца соответственно.

    setFullYear(), setMonth(), setDate(): Установка года, месяца (от 0 до 11) и дня месяца соответственно.

    toString(): Получение строкового представления даты.
    `,
    },
    {
      title: 'MATH в JS',
      quest: `

    Объект Math в JavaScript предоставляет различные методы для выполнения математических операций.
     Вот несколько методов, предоставляемых объектом Math:

    Math.abs(x) возвращает абсолютное число - Math.abs(-5)//5
    Math.ceil(x) округляет вниз
    Math.floor(x) округляет вверх
    Math.round(x) округляет в ближайщую сторону. 0.5 округляеет вверх
    Math.max(10, 5, 8); возвращает максимальное
    Math.min(10, 5, 8); возвращает минимальное
    Math.random() возвращат рандомное число от (включительно) до 1 исключительно
    Math.sqrt(x) Возвращает квадратный корень числа x. Math.sqrt(25)//5
    `,
    },
    {
      title: 'Погружение и всплытие в JS',
      quest: `
    Всплытие (Bubbling):
    Всплытие — это механизм, при котором событие начинает свое восхождение от целевого элемента (где произошло событие) вверх по иерархии DOM.
    Сначала обрабатывается событие на самом вложенном элементе, затем на его родителе, и так далее, вплоть до корневого элемента документа.
    Всплытие является стандартным поведением для большинства событий в DOM.

    Фаза захвата или фаза цели:
    Момент, когда событие достигает целевого элемента, где произошло событие.

    Погружение (Capturing):
    Погружение — это механизм, при котором событие идет вниз по иерархии DOM от корневого элемента к целевому элементу, где произошло событие.
    Погружение является менее используемым, и не все события поддерживают этот механизм. Однако, при добавлении параметра true в метод addEventListener, можно включить режим погружения.


        В JavaScript событие "focus" не имеет стадии погружения или всплытия

        В общем случае событие отрабатывает на стадии всплытия, но при необходимости можно сделать так, чтобы оно
        сработало на стадии погружения. Для этого надо указать true третьим параметром во время навешивания
        события на элемент с помощью addEventListener: element.addEventListener('click', callback, true)


        Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.
        То есть, event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.
        Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

`,
    },
    {
      title: 'Hosting Всплытие',
      quest: `Когда речь идет о "hosting" в контексте JavaScript, обычно имеется в виду понятие "всплытия" (hoisting).
       Всплытие - это механизм в JavaScript, при котором объявления переменных и функций перемещаются вверх
       (в начало) своей области видимости перед выполнением кода.
       Когда вы объявляете переменную с использованием var, объявление переменной всплывает вверх,
       но инициализация остается на месте. В результате переменная сначала будет undefined,
       а затем будет инициализирована значением.


       Функции, объявленные с использованием function, всплывают вверх и могут быть вызваны до их фактического объявления в коде
       .
       `,
    },
    {
      title: 'AJAX и Fetch API:',
      quest: `
    AJAX: AJAX (Asynchronous JavaScript and XML) механизм для получения и отправки данных с сервером без перезагрузки страницы.
     ПРИМЕР:
     // Создаем объект XMLHttpRequest
      var xhr = new XMLHttpRequest();

      // Настраиваем запрос (POST-запрос на сервер по указанному URL)
      xhr.open('POST', 'https://api.example.com/post-endpoint', true);

      // Устанавливаем заголовок Content-Type для передачи данных в формате JSON
      xhr.setRequestHeader('Content-Type', 'application/json');

      // Данные, которые вы хотите отправить (в данном случае, объект JSON)
      var postData = {
        username: 'exampleUser',
        password: 'examplePassword'
      };

      // Преобразуем объект в JSON-строку
      var jsonData = JSON.stringify(postData);

      // Назначаем обработчик события изменения состояния запроса
      xhr.onreadystatechange = function() {
        // Проверяем, что запрос завершен (readyState 4) и статус успешный (status 200)
        if (xhr.readyState === 4 && xhr.status === 200) {
          // Обработка данных, полученных от сервера
          console.log(xhr.responseText);
        }
      };

      // Отправляем данные в теле запроса
      xhr.send(jsonData);


      readyState - это свойство объекта XMLHttpRequest, которое предоставляет текущее состояние выполнения запроса. Когда readyState равно 4, это означает, что запрос завершен, и все данные получены.

      Вот значения readyState и их значения:

      0 (UNSENT): Объект был создан, но метод open() еще не был вызван.
      1 (OPENED): Метод open() был вызван.
      2 (HEADERS_RECEIVED): Метод send() был вызван, и заголовки и статус доступны.
      3 (LOADING): Загрузка; данные частично получены.
      4 (DONE): Операция завершена, и все данные получены.

==================================================================================

    Fetch API:

    Fetch API - это более современный и удобный способ делать асинхронные запросы.
    Он возвращает Promise, что упрощает обработку данных.
    Пример:

    // Данные, которые вы хотите отправить
    const postData = {
      username: 'exampleUser',
      password: 'examplePassword'
    };

    // Опции запроса
    const requestOptions = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json' // Устанавливаем заголовок Content-Type для JSON
        // Другие заголовки, если необходимо
      },
      body: JSON.stringify(postData) // Преобразовываем объект в JSON-строку для тела запроса
    };

    // Выполняем POST-запрос
    fetch('https://api.example.com/login', requestOptions)
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        // Обработка данных
        console.log(data);
      })
      .catch(error => {
        // Обработка ошибок
        console.error('There was a problem with the fetch operation:', error);
      });

    `,
    },
    {
      title: 'Добавление и удаление значений в объекте и массиве',
      quest: `

        Массивы

        Добавление элементов:
        push(value) – добавляет в конец.
        unshift(value) – добавляет в начало.
        splice(index, 0, value) – вставляет на определённую позицию.
        [...arr, value] или [value, ...arr] – добавляет с помощью распаковки.

        Удаление элементов:
        pop() – удаляет последний элемент.
        shift() – удаляет первый элемент.
        splice(index, count) – удаляет по индексу.
        filter() – возвращает новый массив без определённых элементов.

        Объекты

        Добавление/обновление свойств:
        obj[key] = value – добавляет или обновляет свойство.
        Object.assign(obj, { key: value }) – добавляет/обновляет свойства из другого объекта.
        { ...obj, key: value } – с помощью распаковки создаёт новый объект с добавлением свойства.

        Удаление свойств:
        delete obj[key] – удаляет свойство.
        const {value1, ...otherValue} = obj - удаляет поле value1.`,
    },
    {
      title: 'Копирование объектов',
      quest: `
      structuredClone(obj),
      Рекурсивная функция deepClone(obj),
      JSON.parse(JSON.stringify(obj)) - Но этот способ игнорирует такие значения как: undefined, function, Date, потому что в JSON нет таких типов.
      Object.assigne({},  obj)

      `,
    },
    {
      title: 'WEB WORKER, SERVISE WORKER',
      quest: `
    WEB WORKER - это механизм, который позволяет выполнять скрипты в фоновом режиме,
    в отдельном потоке, отдельном от основного потока выполнения JavaScript в веб-приложении.
    Это позволяет выполнять тяжелые вычисления, обрабатывать задачи в фоновом режиме и
    не блокировать основной поток браузера, что способствует более отзывчивому пользовательскому
    интерфейсу.WEB WORKER это отдельный js файл, не имеющий доступа к DOM юраузера и объекту window

    SERVISE WORKER - сервис-воркеры позволяют приложениям продолжать работу в
    автономном режиме в случае потери подключения к интернету. Service Worker используется для
    кэширования ресурсов, таких как HTML-страницы, стили, JavaScript-файлы, изображения и другие
    файлы, полученные с сервера. Эти ресурсы сохраняются в локальном кэше браузера.
    Когда веб-приложение отправляет запрос на сервер, Service Worker может перехватить этот запрос
    и решить, каким образом ответить на него.
    Если есть активное интернет-соединение, Service Worker может отправить запрос на сервер и
    обновить кэш данными с сервера. Если интернет-соединение отсутствует или запрос
    на сервер завершается ошибкой, Service Worker может вернуть ресурсы из локального кэша.
        `,
    },
    {
      title: 'Операторы REST SPREAD',
      quest: `

      Рест оператор используется для сбора аргументов в функции или элементов в массиве. Пример:

        function sum(...numbers) {
          return numbers.reduce((acc, num) => acc + num, 0);
        }
        console.log(sum(1, 2, 3, 4));



      Спрэд оператор используется для распаковки значений из массивов, объектов или строк. Вот пример использования спрэд-оператора с массивом:

        const arr1 = [1, 2, 3];
        const arr2 = [...arr1, 4, 5];

        Или для удаления свойств объекта:

        let obj = {
          a:1,
          b:2,
          c:3
        }

        const {a,b, ...other} = obj


        console.log(other)// {c:3}

      `,
    },
    {
      title: 'Наследование в JS',
      quest: `
      В JavaScript существуют три основных типа наследования:

      1. Прототипное наследование - каждый объект имеет свойство-прототип, которое наследует свойства и методы от
      родительского объекта. При обращении к свойству или методу объекта, которого нет в нем самом, поиск происходит в его прототипе.
      let a=12
      a.toString() это прототипное наследование


      Классическое наследование:
      2. Классическое наследование - основано на классах и объектах-экземплярах.
      Класс определяет общие свойства и методы, которые наследуются экземплярами этого класса

      Миксин наследование:
      3. Миксин-наследование - позволяет объектам наследовать свойства и методы от нескольких источников,
      не создавая полноценную иерархию наследования.
      Это позволяет легко объединять функциональность из разных источников.
      Классическое наследование на основе классов в JavaScript ограничено использованием одного родительского класса,
      но с помощью миксин-наследования можно добавить функциональность нескольких различных источников.

      const canSwim = {
        swim() {
          console.log("Swimming...");
        }
      };

      const canFly = {
        fly() {
          console.log("Flying...");
        }
      };

      class Duck {
        constructor() {
          Object.assign(this, canSwim, canFly);
        }
      }

      const duck = new Duck();

      duck.swim(); // Выводит "Swimming..."
      duck.fly(); // Выводит "Flying..."

      `,
    },
    {
      title: 'Promse.all, Promise.allSettled, Promise.race',
      quest: `

    Promise (промис) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции.


    Promise.all:
    Возвращает новый промис, который разрешается, когда все переданные промисы разрешаются, и отклоняется, если хотя бы один из них отклоняется.
    Промисы, переданные в Promise.all, также выполняются параллельно.
    Результатом Promise.all будет массив значений, разрешенных каждым промисом, в том порядке, в котором они были переданы.

    Promise.race:
    Как только один из переданных промисов разрешится или отклонится,
    результат (значение или ошибка) будет передан в соответствующий обработчик then или catch,
    и остальные промисы будут проигнорированы.

    Promise.allSettled:
    Очень похож на метод Promise.all(), но работает немного по-другому. В отличие от Promise.all(),
    Promise.allSettled() ждёт выполнения всех промисов, при этом неважно, завершились они успешно или с ошибкой.

    `,
    },
    {
      title: 'Методы массивов. Мутабельные и иммутабельные',
      quest: `

      Мутабельные методы:
      pop: Удаляет последний элемент из массива.
      shift: Удаляет первый элемент из массива.
      push: Добавляет один или несколько элементов в конец массива.
      unshift: Добавляет один или несколько элементов в начало массива.
      reverse: Переворачивает порядок элементов в массиве.
      sort: Сортирует элементы массива (по умолчанию, как строки).
      fill: Заполняет все элементы массива значением? переданным как аргумент.
      splice: Удаляя или заменяет элементы массива. splice(1,3,'a','b')//

      Иммутабельные методы:
      slice(): Возвращает подмассив (вырезанную часть) массива, не изменяя оригинальный массив. splice(1,3)
      concat: Объединяет два или более массива, создавая новый массив.
      map: Создает новый массив, содержащий результат вызова предоставленной функции для каждого элемента.
      filter: Создает новый массив, содержащий только те элементы, для которых предоставленная функция возвращает true.
      reduce: Применяет функцию к аккумулятору и каждому элементу массива (слева направо) для свертывания массива в одно значение.
      every: Проверяет, удовлетворяют ли все элементы массива предоставленное условие.
      some: Проверяет, удовлетворяет ли хотя бы один элемент массива предоставленное условие.
      find: Поиска первого элемента в массиве, который удовлетворяет условию в функции обратного вызова.
      Этот метод возвращает значение первого найденного элемента или undefined, если элемент не найден.

      `,
    },
    {
      title: 'PROTO VS PROTOTYPE',
      quest: `
      Все объекты в js имеют __proto__.
      prototype есть только у функций и классов(потому что класс это синтаксический сахар для функции)
      __proto__ ссылается на прототип класса, с помощь. которого был создан.
      Например
      let name = 18 // new String(18)
      let age = 18 // new Number(18)

      у name нет prototype, у него есть proto, которое ссылается на String.prototype

      class Car {}
      function F1(){}

      let b = new F1()  //b.__proto__ === F1.prototype будет true
      console.log(F1.__proto__ === Function.prototype) //true

      let a = new Car() //a.__proto__ === Car.prototype будет true
      console.log(Car.__proto__ === Function.prototype)//true




      `,
    },
    {
      title: 'Дексрипрторы',
      quest: `

     В контексте JavaScript дескрипторы — это объекты, которые определяют свойства и могут быть использованы для более тонкой настройки работы
     свойств объектов.

     Использывание:
     const obj = {};

    Object.defineProperty(
      obj,
      'value1', //название добавляемого свойства
      {
    value: 10,//Устанавливает первоначальное значение
    writable: false,//Доступно только для чтения
    enumerable:false,// Недоступен при итерациях
    configurable:false//можно ли удалить или модифицировать с помощью Object.defineProperty
});
    `,
    },
    {
      title: 'Event loop, как он работает?',
      quest: `
      Изначально все наши функции попадают в callStack и все синхронные функции сразу же выполняются по очереди и выходят оттуда.
      А все асинхронные события отправляются в webApi, откуда после выполнения асинхронной функции они попадают в callback queue,
      где есть два контейнераЖ микротаски и макротаски. Первыми выполняются все микротаски и только потом выполняются макротаски`,
    },
    {
      title: 'Map и Set',
      quest: `
      Map - коллецкция ключ - значение. Ключем может быть другой что угодно. при этом map сохраняет последовательность в цикле.
      Set - коллекция уникальных значений

      Вот основные методы, предоставляемые объектом Map:

      set(key, value): Устанавливает значение для указанного ключа в Map.
      get(key): Возвращает значение, связанное с указанным ключом.
      has(key): Проверяет, существует ли ключ в Map.
      delete(key): Удаляет значение, связанное с указанным ключом.
      clear(): Удаляет все значения из Map.
      size: Возвращает количество элементов в Map.
      keys(): Возвращает итератор по ключам Map.

      const keysIterator = myMap.keys();
      for (const key of keysIterator) {
        console.log(key);
      }

      values(): Возвращает итератор по значениям Map.

      const valuesIterator = myMap.values();
      for (const value of valuesIterator) {
        console.log(value);
      }

      entries(): Возвращает итератор по массивам [ключ, значение] для каждого элемента Map.

      const entriesIterator = myMap.entries();
      for (const [key, value] of entriesIterator) {
        console.log(key, value);
      }

      forEach(callbackFn): Вызывает указанную функцию обратного вызова для каждого элемента Map.

      myMap.forEach((value, key) => {
        console.log(key, value);
      });






      Вот основные методы, предоставляемые объектом Set:

      add(value): Добавляет значение в Set. Если значение уже присутствует, метод не выполняет никаких изменений.
      delete(value): Удаляет значение из Set. Возвращает true, если значение было в Set и успешно удалено, и false в противном случае.
      has(value): Проверяет, содержится ли значение в Set. Возвращает true, если значение присутствует, и false в противном случае.
      clear(): Удаляет все значения из Set.
      size: Возвращает количество элементов в Set.
      keys() (или values()): Возвращает итератор по значениям в Set. Обратите внимание, что у Set ключи и значения совпадают.
      entries(): Возвращает итератор по массивам [значение, значение] для каждого элемента Set.
      forEach(callbackFn): Вызывает указанную функцию обратного вызова для каждого элемента Set.

      `,
    },
    {
      title: 'Как сделать объект иммутабельным',
      quest: `
      С помощью Object.freeze. Он запрещает удаление, добавление или изменение текущих свойств.
      Но мы по прежнему сможем поменять свойства вложенных объектов.


      Object.seal используется для запрета добавления новых свойств к объекту и удаления существующих свойств.
      Однако, оно также делает все существующие свойства объекта неперечислимыми (non-configurable),
      что означает, что их нельзя будет удалить с помощью оператора delete. Это делает объект "запечатанным" (sealed).
      Но свойства по-прежнему могут быть изменены.

      Когда мы захотим что то поменять в иммутабельном стиле, мы должны будем скопировать объект
      с помощью Object.assigne({}, obj) или {...obj}.

      Так же assigne позволяет объединить методы, исключив дубликаты ключей
      `,
    },
    {
      title: 'Как сделать поле класса приватным',
      quest: `
      Есть соглашение, что если поле является привантым, то нужно писать перед ним _, но в последниx версиях JS появилась возможность
      добавить перед полем "#" и поле станет приватный. то есть нельзя быдет обратиться к немук извне. Если в TS то private`,
    },
    {
      title: 'В чем отличие примитивных и непримитивных типов данных',
      quest: `
      Во первых,ссылочные типы могут иметь методы, свойства.
      Во вторых, примитивы сравниваются по значению, а непримитивы по ссылке.
      В третьи, примитивы являются иммутабельными. Мы не можем их изменять, а можем только перезаписать
      `,
    },
    {
      title: 'Что такое замыкание',
      quest: `
      Замыкание (closure) - это свойство функции сохранять доступ к переменным из
      внешней области видимости, даже после того, как эта область видимости завершила свою работу.

      В JavaScript у функций есть скрытое свойство [[Environment]], которое связывает функцию с её лексическим окружением или «замыканием».
      Это свойство недоступно для прямого доступа из кода, но оно играет важную роль в создании и сохранении замыканийю.

      `,
    },
    {
      title: 'Что делать если потерял this?',
      quest: `
      Привязать с помощью .bind или apply. Bind не вызывает, а только связывает. А apply вызыввает сразу`,
    },
    {
      title: 'Что такое частичное применение? Каррирование?',
      quest: `
      Частичное применение это когда мы вызываем функцию с некоторыми, но не всеми параметрами, и возвращаем новую функцию,

      которая уже принимает остальные параметры.

      Пример 1:

      const f1 = (a, b) => {
        return a + b;
      };

      const f2 = (a) => (b) => f1(a, b);

      const f3 = f2(1)

      console.log(f3(2)) // 3

      Пример 2:

      const f1 = (a, b) => {
        return a + b;
      };

      const f2 = f1.bind(null, 1 )
      console.log(f2(2)) // 3


      Каррирование это преобразование одной функции, которая принимает несколько аргументов в последовательность вложеннных
      функций, которые принимают по одному параметру.

      Пример:

      const f1 = (a, b) => {
        return a + b;
      };

      const f2 = a=>b=>a+b
      f2(1)(2) // 3

      `,
    },
    {
      title: 'Как удалить поле из объекта в иммутабельном стиле?',
      quest: `Скопировать с помощью спред оператора и удалить уже из нового объекта

      const {element,  ...newObj} = obj
      В newObj будет лежать объект без поля element
      `,
    },
    {
      title: 'Как работает .reduce()',
      quest: `

      reduce() - это метод массивов в JavaScript, который применяет функцию к аккумулятору и каждому элементу массива (слева направо),
      чтобы свести массив к одному значению. Вот простое объяснение:

      Аргументы:

      Функция обратного вызова (callback): Эта функция выполняется для каждого элемента массива и принимает четыре параметра: аккумулятор,
      текущий элемент, текущий индекс и сам массив.
      Начальное значение аккумулятора (опционально): Значение, которое будет использоваться в качестве первого аргумента при первом вызове
      функции обратного вызова.
      Как работает:

      reduce() начинает с первого элемента массива, используя его значение и начальное значение (если оно предоставлено) в качестве аккумулятора.
      Затем функция обратного вызова применяется к следующему элементу массива, используя текущее значение аккумулятора и значение элемента.
      Этот процесс повторяется для каждого элемента массива, каждый раз обновляя значение аккумулятора.
      В конце reduce() возвращает окончательное значение аккумулятора.
      Пример:


      const numbers = [1, 2, 3, 4, 5];

      const sum = numbers.reduce((accumulator, currentValue) => {
        return accumulator + currentValue;
      }, 0);

      console.log(sum); // 15`,
    },
    {
      title: 'Что такое промисы',
      quest: `
      Promise это класс в js для работы работы с асинхронным кодом
      Промисы имеют три состояния:

      Ожидание (Pending): Начальное состояние, когда промис создан, но результат еще не известен.

      Исполнено (Fulfilled): Операция завершена успешно, и промис вернул результат.

      Отклонено (Rejected): Операция завершена с ошибкой, и промис вернул ошибку.

      Конструктор принимает два метода Resolve и Reject. Resolve отвечает за успешное выполнение а reject вызывается,
      чтобы вернуть оишбку при неудачном выполнении.

      Промисы в JavaScript имеют три основных метода: then, catch и finally:

      then:
      Используется для обработки успешного завершения промиса. Принимает колбэк, который выполняется, когда промис успешно завершается.

      catch:
      Используется для обработки ошибок, произошедших во время выполнения промиса. Принимает колбэк, который выполняется в случае ошибки.

      finally:
      Используется для указания блока кода, который будет выполнен независимо от того, успешно завершился промис или произошла ошибка. Принимает колбэк, который выполняется всегда, независимо от результата промиса.

      `,
    },
    {
      title: 'В чем отличие стрелочных функций?',
      quest: `
      1. Не имеют внутри себя объект arguments
      2. Нельзя обратиться до их объявление
      3. Не имеют своего this. Берет извне
      4. синтаксис
      `,
    },
    {
      title: 'Что такое рекурсия?',
      quest: `
      Это функцияЮ вызывающая сама себя
      `,
    },
    {
      title: 'Heap и Stack',
      quest: `

      Стек (stack) — это статическое выделение памяти.
      Это структура данных, которая используется для хранения статических данных, их размер всегда известен во время компиляции.
      В JS сюда включили примитивные значения, например string, number, boolean, undefined и null, а также ссылки на функции и объекты.
      Движок «понимает», что размер данных не меняется, поэтому выделяет фиксированный объем памяти для каждого из значений

      Куча (heap) — динамическое выделение памяти
      Что касается кучи, то она знакома многим не хуже, чем стек. Используется она для хранения объектов и функций.
      Но в отличие от стека движок не может «знать», какой объем памяти необходим для того либо иного объекта, поэтому память выделяется по мере необходимости.
      И этот способ выделения памяти называется «динамическим»


      кОГДА МЫ СОЗДАЕМ НОВЫЙ ОБЪЕКТ, ССЫЛКА НА ЭТОТ ОБЪЕКТ ХРАНИТСЯ В СТЕКЕ, А САМ ОБЪЕКТ В КУЧЕ


      ЧИСТКА МУСОРА:
      Как только движок «видит», что в переменной или функции уже нет необходимости, выполняется освобождение памяти.
      Он убирает те объекты, на которые не указывает более ни одна ссылка. Вот пример, который неплохо все разъясняет.


      `,
    },
  ];
  TS: QuestsArr = [
    {
      title: 'Перегрузки в TS',
      quest: `
      Это когда мы несолько раз указываем разную сигнатуру для функции, и в зависимости от типа входных данных возвращаем определенные типа

      function foo(a:number):string
      function foo(a:string):number
      function foo(a:any){
        if(typeof a === 'string'){
          return +a
        } else{
          return a.toString()
        }

      }

      let f1 = foo('1')//ожидает number
      let f2 = foo(1)// ожидает string

`,
    },
    {
      title: 'Декораторы',
      quest: `


      В TypeScript декораторы предоставляют механизм для добавления, изменения или расширения поведения классов и
       их членов (методов, свойств, параметров и т. д.). Они предоставляют средство для аннотации и модификации кода в более декларативном и гибком стиле.

       пример:

       function logClass(target: Function) {
        console.log(Class name: {target.name});
      }

      @logClass
      class ExampleClass {
      }

      Сработает сразу же при созданиии экземпляра класса+
    `,
    },
    {
      title: 'Отличие абстрактных классов от интерфейса',
      quest: `
      Абстрактный класс в TypeScript:

      Может содержать абстрактные методы (без реализации) и конкретные методы (с реализацией).
      Может содержать переменные класса (поля).
      Поддерживает только одиночное наследование. Нельзя наследоваться от двух или более классов(без разницы абстрактный или других)
      Может иметь конструктор.
      С помощью абсрактоного класса можно создавать легковесные инжекшен токены(lightweight injection tokens)

    `,
    },
    {
      title: 'Объединение и пересечение типов',
      quest: `
      Объединение типов = number | string // Может быть либо string либо number
      Пересечение типов = interface1 & interface2 // должен содержать методы и свойства обеих интерфейсов
    `,
    },
    {
      title: 'Отличие type vs interface',
      quest: `

      Interface, когда вам нужно описать форму объекта.
      Type, когда вам нужно создать юнион тип/объединенный тип или тип, который не является объектом: type Age = number.


      type:
      1. можно задать тип для примитивного значения
      type id = number
      2. Можно создать юнион тип/объединенный тип
      3. Тип не может быть объявлен дважды. А интерфейс в таком случае расширяют предыдущий интерфейс

      Пример:

      type a = string:number

      Пример 2:

      type Num = {
        age:number
      };

      type Str = {
        name: string
      };

      type NumStr = Num | Str; // Объединение или одно из двух


      interface: Интерфейсы обычно используются для описания формы объектов или контрактов, а не для создания примитивных значений типов.
    `,
    },
    {
      title: 'Что такое дженерики?',
      quest: `
      C помощью дженериков в TypeScript вы можете создавать обобщенные типы данных, которые могут работать
      с различными типами. Эти обобщенные типы могут быть использованы как переменные для различных типов данных,
      обеспечивая гибкость и повторное использование кода.
      То есть рассмотреть дженерик можно как функцию которую мы вызываем с определенным типом,
      и которая возвращает структуру с использыванием переданного типа.
      То есть мы с помощью дженериков может указать какой то временный тип, которыя является заменой
      какому то конкретному типу, и который мы указываем налету во врмея вызова функции или создания интерфейса

      Преимущества использования дженериков:

      Универсальность: Дженерики позволяют писать более гибкий и универсальный код, который может работать с разными типами данных.

      Повторное использование: Дженерики способствуют повторному использованию кода, так как вы можете создавать универсальные компоненты.`,
    },
    {
      title: 'Отличие unknown от any?',
      quest: `

      1. TypeScript отключает для any большинство проверок типов, что может привести к потенциальным ошибкам во время выполнения.

      1. Переменные типа unknown более безопасны, чем any, потому что TypeScript не позволяет выполнить большинство
      операций с unknown без явных проверок типов или приведения типов.
      Использование unknown обеспечивает более строгую безопасность типов по сравнению с any.


      let variable: unknown = "Привет";
      console.log(variable.toUpperCase()); // Работает без ошибок

      .......................................................

      let variable: unknown = "Привет";

      if (typeof variable === "string") {
        console.log(variable.toUpperCase());}
      //Без проверки будет ошибка
      `,
    },
    {
      title: 'Type guards',
      quest: `

    Type guards (стражи типов) в TypeScript - это проверки типов, которые помогают компилятору TypeScript узнать точно, с каким типом работать.
    Это позволяет писать более безопасный код, уменьшая вероятность ошибок.
    TypeScript поддерживает несколько видов type guards:

    1 Типовые проверки (Typeof type guards):
    Основаны на операторе typeof.

    2 Инстансоф типовые проверки (Instanceof type guards):
    Основаны на операторе instanceof.

            class Cat {
          meow() {
            console.log('Meow!');
          }
        }

        class Dog {
          bark() {
            console.log('Woof!');
          }
        }

        function makeSound(animal: Cat | Dog) {
          if (animal instanceof Cat) {
            animal.meow(); // TypeScript знает, что это Cat
          } else if (animal instanceof Dog) {
            animal.bark(); // TypeScript знает, что это Dog
          }
        }

    3 Функции, которые возвращают булево значение и используются в качестве типовых стражей.

        type Admin = { role: 'admin'; adminName: string[] };
        type User = { role: 'user'; userName: string };

        type Person = Admin | User;

        function isAdmin(person: Person): person is Admin {
          return person.role === 'admin';
        }

        function isUser(person: Person): person is User {
          return person.role === 'user';
        }

        function greet(person: Person) {
          if (isAdmin(person)) {
            console.log('person.adminName);
          } else if (isUser(person)) {
            console.log('person.userName);
          }
        }

`,
    },
    {
      title: 'В чем отличие enum и const enum',
      quest: `
      Перечисления в TypeScript нужны для того, чтобы задать именованные значения, которые часто используются в коде.
      Это делает код более читаемым, помогает избежать ошибок и облегчает работу с определенными типами данных.

      Компиляция:

      Во время компиляции enum превращается в объект JavaScript, который может быть использован во время выполнения.
      В отличие от обычного enum, const enum во время компиляции полностью удаляется, и в JavaScript код не оставляется.

`,
    },
    {
      title: 'Utility типы pick, omit, parameters, return и т.д',
      quest: `
      Pick<User, "name" | "age" ...>: Позволяет выбрать из типа User только те свойства, которые перечислены после запятой

      Omit<User, "name" | "age" ...>: Позволяет исключить из типа User те свойства, которые перечислены после запятой.

      Parameters<T>: Получает тип параметров функции T.

      ConstructorParameters<Type> - извлекает типы аргументов конструктора Type.

      ReturnType<T>: Получает тип возвращаемого значения функции T.

      Partial<T>: делает все свойства объекта типа T необязательными.

      Required<T> - делает все свойства объекта типа T обязательными.

      Readonly<T> - делает все свойства объекта типа T доступными только для чтения.

      Record<Keys, Type> - создает тип, который является записью с ключами, определенными в первом параметре, и значениями типа, определенного во втором параметре.

      type Keys = 'a' | 'b' | 'c';
      type RecordType = Record<Keys, number> = { a: number, b: number, c: number }




      Extract<Type, Union> - извлекает из типа Type только те типы, которые присутствуют в Union.
      type A = 'a' | 'b' | 'c';
      type B = 'a' | 'b'| 'e';
      type C = Extract<A, B>;//тип "a" | "b"

      NonNullable<Type> - извлекает тип из Type, исключая null и undefined.

      let value: string | null | undefined;
      let nonNullableValue: NonNullable<typeof value>;
      // теперь nonNullableValue это string


      Uppercase<StringType>, Lowercase<StringType>, Capitalize<StringType>, Uncapitalize<StringType> - это утилитные типы для манипуляции строками, которые изменяют регистр строки в соответствии с их именем.

      type Uppercased = Uppercase<'hello'>; // 'HELLO'
      type Lowercased = Lowercase<'Hello'>; // 'hello'
      type Capitalized = Capitalize<'hello'>; // 'Hello'
      type Uncapitalized = Uncapitalize<'Hello'>; // 'hello'

`,
    },
    {
      title: 'Для чего нужен тип never?',
      quest: `
        Тип never используется для представления кода, который никогда не завершает свое выполнение или не возвращает значение.
        Например функция, которая вызывает ошибку throw new Error(). Она не завершится, а вызовет ошибку.
        Или функция, которая запустила вечный цикл
`,
    },
  ];
  NGRX: QuestsArr = [
    {
      title: 'ЭКШНЫ Actions ',
      quest: `
    В NGRX экшны (actions) представляют собой объекты, которые описывают события или действия, происходящие в вашем приложении.

    export const CommentsActions = createActionGroup({
      source: 'Comment',
      events: {
        getComment: emptyProps(),
        getCommentSuccess: props<{ comment: CreateComment }>(),

      },
    });


    `,
    },
    {
      title: 'Reducer Редьюсеры',
      quest: `


    В NGRX редукторы (reducers) являются чистыми функциями, которые принимают текущее состояние и экшн,
    а затем возвращают новое состояние. Они играют ключевую роль в управлении состоянием приложения в хранилище (store)

        export interface CounterState {
          count: number;
        }

        const initialState: CounterState = {
          count: 0
        };

        export const counterReducer = createReducer(
          initialState,
          on(counterActions.increment, state => ({
            ...state,
            count: state.count + 1
          })),
          on(counterActions.decrement, state => ({
            ...state,
            count: state.count - 1
          })),
          on(counterActions.reset, () => initialState)
        );


      `,
    },
    {
      title: 'Селекторы',
      quest: `
      В NGRX селекторы (selectors) - это функции, которые используются для извлечения определенных частей состояния из хранилища (store).
       Они позволяют получить доступ к данным в хранилище и преобразовать их в нужный формат для использования в компонентах.


      // Селектор для получения состояния пользователя
      export const selectUserState = (state: AppState) => state.user;

      // Селектор для получения списка пользователей
      export const selectUsers = createSelector(
        selectUserState,
        (state) => state.users
      );

      // Селектор для получения статуса загрузки
      export const selectLoading = createSelector(
        selectUserState,
        (state) => state.loading
      );

      // Селектор для получения ошибки
      export const selectError = createSelector(
        selectUserState,
        (state) => state.error
      );


      `,
    },

    {
      title: 'Эффекты',
      quest: `


    В NGRX эффекты (effects) представляют собой часть библиотеки, которая предназначена для обработки побочных эффектов в вашем приложении,
     таких как асинхронные HTTP-запросы, чтение/запись в локальное хранилище браузера и другие асинхронные операции.
     Эффекты позволяют обрабатывать эти операции в одном месте, что делает управление побочными эффектами более простым и предсказуемым.


  loadUsers$ = createEffect(() => {
  let actions = inject(Actions)
  let apiService = inject(ApiService)
    actions$.pipe(
      ofType(userActions.loadUsers),
      switchMap(() => apiService.getUsers()
        .pipe(
          map(users => userActions.loadUsersSuccess({ users })),
          catchError(error => of(userActions.loadUsersFailure({ error })))
        ))
      )

  }
  , {functional: true});


    `,
    },
  ];
  RXJS: QuestsArr = [
    {
      title: 'Операторы высшего порядка',
      quest: `
      Эти операторы предоставляются библиотекой RxJS и используются в контексте работы с потоками данных (Observables). Вот краткое описание каждого из них:

      switchMap:  Получая новое значение, подписывается на новый поток, тут же отписавшись от предыдущего.

      mergeMap:  Получая новое значение, подпишется на новый поток, не отписываясь от предыдущего
      Вторым параметром принимает число, которое ограничивает количество параллельно выполняющихся потоков

      concatMap: Получая новое значение, подпишется на него, не отписываясь от предыдущего и выполнит их в строго заданном порядке

      exhaustMap: Получая новое значение, игнорирует все последующие эмиты, пока не выполнит запрос по первому.

      `,
    },
    {
      title: 'Отличие горячего и холодного потока',
      quest: `
      Горячий поток - активен независимо от того, есть ли подписчики,
      Холодный поток - начинает исполнение только при подписке.

      Холодный поток — это поток, источник данных которого создается внутри конструктора Observable.
      Каждый новый подписчик - новый поток.

      Горячий поток — это поток, источник данных которого создается снаружи конструктора Observable.
      Источник данных один для всех подписчиков


      Можно подогреть холодный поток с помощью shareReplay(1). Это называется мультикастинг.
      Суть заключается в том, что shareReplay создает внутри subject и прокидывает даные туда
      и подписчики подписываются уже на это сабжект.
      Этот меанизм позволяет например сделать азапрос к серверу только один раз и раздать данные всем подписчикам

      `,
    },
    {
      title: 'Higher order observables',
      quest: `
      Higher order observables - потоки, создающие другие потоки.
      of(1,2,3,4).pipe(
        map(value=>of(value))
      )

      или

      of(1,2,3,4).pipe(
        map(value=>of(value))
      ).subscribe(value=>value.subscribe())

      `,
    },
    {
      title: 'Виды Subject',
      quest: `
      Subject - это обычный subject без начального значения, который является и наблюдателем и наблюдаемым.

      BehaveurSubject - это subject с первоначальным значением. Он хранит последнее отправленное значение и передает его новым подписчикам при подписке.
      имеет дополнительный метод и свойство, которых нет у обычного Subject. Вот они:
      getValue(): Этот метод возвращает текущее значение, хранящееся в BehaviorSubject. Это полезно, если вам
      нужно получить текущее значение без подписки.
      Свойство value предоставляет доступ к текущему значению

      ReplaySubject -Запоминает несколько (или все) последних значений и передает их новым подписчикам при подписке.
      ReplaySubject.getBufferedValues(). Этот метод полезен, если вы хотите получить доступ к текущему состоянию буфера.
      new ReplaySubject<number>(2, 1500); //запомнит 2 значение в течение 1500милисекундн. Затем забудет

      AsyncSubject - Хранит только последнее значение и передает его только при вызове complete().
      `,
    },
    {
      title: 'Мультикастинг',
      quest: `
      Мультикастинг в RxJS — это механизм, позволяющий переиспользовать поток событий между несколькими подписчиками,
      избегая повторного выполнения вычислений при каждой новой подписке.

      const get = ajax.get('https://jsonplaceholder.typicode.com/posts/1').pipe(share())
      get.subscribe()
      get.subscribe()//Запрос отправится лишь один раз
      `,
    },
    {
      title: 'Аналог Promise.all в RxJS',
      quest: `
     CombineLatest и ForkJoin.

     CombineLatest
     Создает новый поток, который эмитит массив из последних значений от каждого исходного потока,
     когда каждый из них заэмитит хотя бы одно значение.

     ForkJoin
     Создает новый поток, который эмитит массив из последних значений от каждого исходного потока, когда все потоки завершатся
     `,
    },
    {
      title: 'Комбинирование потоков в Rxjs',
      quest: `
      concat: Объединяет несколько потоков в один, но сначала дожидается завершения предыдущего потока, прежде чем начать следующий.
      const source1 = timer(1000).pipe(map(()=>'1'));
      const source2 = timer(500).pipe(map(()=>'2'));
      const func = concat(source1, source2);
      func.subscribe(value => console.log(value)); ///Через 1 секеудну 1, после, через 0.5 секунд 2

      merge: Объединяет несколько потоков в один, сохраняя порядок поступления событий от всех потоков. То есть потоки идут параллельно
      const source1 = timer(1000).pipe(map(()=>'1'));
      const source2 = timer(500).pipe(map(()=>'2'));
      const func = merge(source1, source2);
      func.subscribe(value => console.log(value)); ///Через 0.5 секеудн 2, после, через 0.5 секунд 1
     `,
    },
    {
      title: 'Когда и как нужно отписываться, что если не отписаться?',
      quest: `
      Отписка в RxJS важна для предотвращения утечек ресурсов и избыточного использования памяти. Постепенное накопление утекшей памяти может
      привести к увеличению потребления памяти приложением, в конечном итоге вызвав проблемы с производительностью и стабильностью приложения.

    Метод 1 : takeUntil(this.destroy$)

    export class MyComponent implements OnDestroy {
      private destroy$ = new Subject<void>();

      constructor() {
        of(1)
          .pipe(takeUntil(this.destroy$))
          .subscribe();
      }

      ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
      }
    }

    Метод 2: takeUntilDestroyed()

    export class MyComponent {
      constructor() {
        interval(1000)
          .pipe(takeUntilDestroyed())
          .subscribe();
      }
    }

    Но есть пользоваться этим методом вне контекства внедрения(то есть в жизненных циклах или обычных функиях),
    то нужно передать параметром DestroyRef, который представляет текущий контекст. Контекст внедрения это это место,
     где Angular инъектирует зависимости. Это конструктор и тело класса(сервиса или компонента)
    Контекст внедрения в Angular - это место, где Angular инъектирует зависимости (сервисы, другие компоненты и т. д.)
    в конструктор компонента или сервиса. Этот процесс осуществляется с использованием механизма Dependency Injection.

    export class MyComponent implements ngOnInit {
      destroyRef = inject(DestroyRef)
      ngOnInit() {
        interval(1000)
          .pipe(takeUntilDestroyed(this.destroyRef))
          .subscribe();
      }
    }

    Метод 3: Использование async пайпа в шаблоне.

    Метод 4: Собрать все потоки в массив и при уничтожении компонента пройтись по ним методом
    перебора и вызвать у каждого метод subscribe

      `,
    },
    {
      title: 'Как создать свой оператор в RxJs',
      quest: `
      Чтобы создать оператор, нужно создать функцию, которая принимает исходный Observable и
      возвращает новый измененный Observable.

      Пример:

      function multiplyBy(factor: number): OperatorFunction<number, number> {
        return (source: Observable<number>) =>
          source.pipe(
            map(value => value * factor)
          );
      }

      // Использование
      const source = of(1,2,3)

      source.pipe(multiplyBy(10)).subscribe(console.log)///10,20,30

      Описание:

      multiplyBy - это функция, которая принимает один аргумент factor, представляющий число, на которое будут умножаться значения в потоке.
      OperatorFunction<number, number>:

      OperatorFunction - это обобщенный интерфейс RxJS, представляющий оператор, который принимает значения одного типа (number в этом случае) и возвращает значения того же типа.
            Возвращаемая функция:

      multiplyBy возвращает функцию, которая является оператором. Эта функция принимает source (исходный Observable) и возвращает новый Observable, который модифицирован согласно определенному оператору.
      source.pipe(...):

      source - это исходный поток значений типа number, который будет модифицирован оператором.
      source.pipe(...) - метод pipe принимает операторы и возвращает новый Observable, который представляет собой результат применения этих операторов к исходному потоку.
      map(value => value * factor):

      map - это стандартный оператор RxJS, который применяет функцию к каждому значению в потоке.
      В данном случае, используя map, каждое значение в потоке умножается на factor.
      `,
    },
  ];
  ANGULAR: QuestsArr = [
    {
      title: 'Динамичесские классы в ангуляр',
      quest: `
      <div [class.admin]="isAdmin" [style.color]="isRed ? 'red' : 'blue'">Content</div>
      <div [ngClass]="{'admin': isAdmin}" [ngStyle]="{'color': isRed ? 'red' : 'blue'}">Content</div>

      `,
    },
    {
      title: 'Маршрутизация',
      quest: `
      Переход по маршруту:

        Из шаблона:
        1.<div routerLink="user" ></div>
        2.<div [routerLink]="['/user', user.id]" [queryParams]="{ paramName: 'paramValue' }"></div>

        Из модели:
        router = inject(Router)
        this.router.navigate(['/user', this.user.id], { queryParams: { paramName: 'paramValue' } });

      Получение данных:
        activatedRouter = inject(ActivatedRouter)

        Подпискана на получение данных:
        this.activatedRouter.params.subscribe()
        this.activatedRouter.queryParams.subscribe()

        Получение снимка без подписки:
        this.activatedRouter.snapshot.params // Получение объекта с параметрами
        this.activatedRouter.snapshot.queryParams // Получение объекта с кверипараметрами







      `,
    },
    {
      title: 'Что такое angular tree shaking',
      quest: `
      Это процесс встряхивание, который удалет код, которы мы не используем. Это делается с помощью вебпак при сборке.
      Напримем, если мы укажем сервису @Injectable({providedIn: "root"}) и не будем им пользоваться, то он удалится
      из конечной сборки. Так работает tree shaking
        `,
    },

    {
      title: 'Инкапсуляция стилей в Ангуляре: ng-deep viewIncapsulation',
      quest: `
      Инкапсуляция стилей в ангуляр производится с помощью добавления хэша к компонентам и к css селекторам при компиляции.
      Можно выбрать viewIncapsulation none. В таком случае хэширование уберется и у компонентов и у селекторов, а если применить
      ng-deep, то хэширование уберется только у определенного селектора, а у компонентов останется.
        `,
    },
    {
      title: 'Жизненный цикл компонента',
      quest: `

    Итак, компонент проходит следующие этапы жизненного цикла

    конструктор: сначала выполняется конструктор компонентам

    ngOnChanges: вызывается до метода и только в том случае, если есть входные данные

    ngOnInit: вызывается только  после инициализации компонента и всех его свойств

    ngDoCheck: вызывается при каждом запуске механизма обнаружения изменений в компонене

    ngAfterContentInit: вызывается после того, как инициализированы все вложенные в ng-content компоненты

    ngAfterContentChecked: вызывается после того, как механизм обнаружения изменений прошёлся по содержимому (content) компонента

    ngAfterViewInit: вызывается  после того, как инициализировано представление компонента

    ngAfterViewChecked: вызывается после того, как механизм обнаружения изменений прошёлся по представлению компонента

    ngOnDestroy: вызывается перед тем, как фреймворк Angular удалит компонент.

    `,
    },
    {
      title: 'Интерсепторы',
      quest: `
    Это перехватчики запросов. С помощью интерсептора мы можем например перехватит запрос и добавить
    к нему JWT токен в заголовки:

    Пример:
    @Injectable()
    export class MyInterceptor implements HttpInterceptor {
      intercept(
        request: HttpRequest<any>,
        next: HttpHandler
      ): Observable<HttpEvent<any>> {
        // Выполнение кода перед отправкой запроса

        // Модификация запроса (если необходимо)
        const modifiedRequest = request.clone({
          setHeaders: {
            'Authorization': 'Bearer YourTokenHere',
          },
        });

        // Передача модифицированного запроса следующему обработчику
        return next.handle(modifiedRequest);
      }
    }
    `,
    },
    {
      title: 'Pipe в агуляр. Pure vs ImPure',
      quest: `
    В Angular пайпы (pipes) представляют собой функции, используемые для преобразования данных в шаблонах.
     Они позволяют изменять отображение данных перед выводом их в пользовательском интерфейсе.

     В ангуляре есть встроенные пайпы (date, async, json, currency и т.д).
     Мы так же можем написать свои пайпы:

    @Pipe({
      name: 'multiplier'
      pure: false // Установка грязного режима
    })
    export class MultiplierPipe implements PipeTransform {
      transform(value: number, factor: number = 1): number {
        return value * factor;
      }
    }

    ...

    <p>Multiplied Value: {{ originalValue | multiplier:2 }}</p>

    Есть понятие чистых пайпов и нечистых пайпов.
    Чистый пайп пересчитывается только при изменении значения, а не при каждом рендере страницы, в отличие от нечистого.
    По умолчанию любой пайп является чистым.
    Чтобы сделать пйп нечистым, нужно в декораторе указать pure:false
    `,
    },
    {
      title: 'Resolution modifier: @Self, @SkipSelf, @Host, @Options',
      quest: `
      В Angular skipSelf, self, optional, и host представляют собой опции, которые могут использоваться
      в конструкторе инжектора компонентов для уточнения, как должны разрешаться зависимости.

      @SkipSelf()
      Декоратор, который указывает инжектору компонента пропустить поиск зависимости в собственном инжекторе
      и начать поиск в инжекторе родительского компонента.

      @Self()
      Декоратор, который говорит инжектору компонента использовать только свой собственный инжектор
      для разрешения зависимости, а не подниматься вверх по иерархии компонентов.

      @Optional()
      Декоратор, который указывает инжектору компонента, что зависимость не является обязательной.
      Если зависимость не найдена, инжектор не выдаст ошибку, а просто установит значение в null
      (или предоставит значение по умолчанию, если оно определено).

      @Host()
      Декоратор, который указывает, что нужно искать зависимость только в родительском КОМПОНЕНТ-инжекторе, пропустив свой

      `,
    },
    {
      title: 'Guards в ангуляр',
      quest: `
      Это классы, которые используются для защиты маршрутов.
      Пример:

      @Injectable({
        providedIn: 'root'
      })
      export class AuthGuard implements CanActivate {

        constructor(private authService: AuthService, private router: Router) {}

        canActivate(
          next: ActivatedRouteSnapshot,
          state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {

          if (this.authService.isAuthenticated()) {
            // Пользователь аутентифицирован, разрешаем активацию маршрута
            return true;
          } else {
            // Пользователь не аутентифицирован, перенаправляем на страницу входа
            this.router.navigate(['/login']);
            return false;
          }
        }
      }

      CanActivate:
      Гвард CanActivate определяет, может ли маршрут быть активирован.
       Этот гвард часто используется для проверки прав доступа пользователя перед активацией маршрута.

      CanActivateChild:
      Гвард CanActivateChild подобен CanActivate, но применяется к дочерним маршрутам.
      Он проверяет, может ли дочерний маршрут быть активирован.

      CanDeactivate:
      Гвард CanDeactivate определяет, может ли маршрут быть деактивирован.
      Он часто используется для предотвращения закрытия страницы или выполнения каких-то действий перед закрытием маршрута.

      Resolve:
      Гвард Resolve используется для предварительной загрузки данных перед активацией маршрута.
      Он может быть использован для получения данных, необходимых для компонента, прежде чем компонент будет отображен.


      `,
    },
    {
      title: 'Как загружается ангуляр приложение в браузере',
      quest: `

      Запуск Angular-приложения в браузере включает в себя несколько шагов. Вот общий порядок событий:

      Загрузка HTML:
      Браузер начинает процесс загрузки вашего Angular-приложения с файла index.html. который
       содержит тег <app-root>, который является
      точкой входа для вашего Angular-приложения

      Загрузка и исполнение JavaScript:
      В файле index.html есть тег <script> с атрибутом src, который указывает на файл сборки main.js.
      Браузер загружает этот файл и начинает исполнять в
      нем содержащийся JavaScript-код.

      Инициализация Angular-приложения:
      Когда браузер исполняет JavaScript-код, Angular-фреймворк начинает инициализацию приложения.
      Angular ищет корневой компонент, который обычно указывается в метаданных
      bootstrap модуля приложения.

      Инициализация AppModule:
      Angular создает экземпляр корневого модуля приложения (AppModule) и начинает его инициализацию.
      В модуле происходит конфигурация и регистрация всех компонентов, сервисов и других зависимостей,
      используемых в приложении.

      Создание корневого компонента:
      Когда модуль проинициализирован, Angular создает экземпляр корневого компонента (AppComponent).
      Этот компонент связывается с элементом в DOM, обозначенным как <app-root> в index.html.
      Это место является точкой входа для вашего приложения в DOM.

      Инжекция зависимостей и жизненный цикл компонентов:
      Angular управляет жизненным циклом компонентов, вызывая соответствующие методы, такие как
      ngOnInit, ngOnChanges и т.д., и предоставляя им необходимые зависимости.

      Отрисовка и обновление представления:
      Angular начинает процесс отрисовки представления на основе данных, связанных с компонентами.
      Любые изменения данных или события, такие как клики или обновления, могут вызывать перерисовку
      представления.

      Ждет событий и обновлений:
      После инициализации Angular-приложение ждет событий, таких как пользовательские взаимодействия,
      HTTP-запросы или изменения состояния, и реагирует на них, обновляя представление при необходимости.

      Эти шаги демонстрируют основной процесс загрузки и инициализации Angular-приложения в браузере.
      Отметьте, что Angular работает на клиентской стороне (frontend), и поэтому весь код
      выполняется в браузере пользователя.
      `,
    },
    {
      title: 'Ng-content, ng-template, ng-container',
      quest: `
      1. ng-contetn: используется для отображения контента, который вставаляется между тегами
      компонента. Можнои спользовать селектор чтобы определить, какой контент будет вставлен
      в определенное место внутри компонента.

      Селекторы можно выбирать как в css
      <ng-content select=".header"></ng-content> // по классу
      <ng-content select="span"></ng-content>// по тегу
      <ng-content select="[data-header]"></ng-content> <!-- Выберет элементы с атрибутом data-header -->




      2. ng-template: определяет шаблон, который не отображается по умолчанию.
      Примеры использывания: Для отображения прелоадера

      <div *ngIf="true; else loading" ></div>
      <ng-template #loading >Загрузка</ng-template>

      Второй пример: Для отображения повторяющегося шаблона в разных частяъ кода с разными данными
      <ng-container *ngTemplateOutlet="tmplt; context:{$implisit: 'Hello'}" ></ng-container>
      <ng-template #temlt let-item >{{item}}</ng-template>

      3. ng-container: Для группировки какого то контента, для применения к этому контенту какой то директивы.
      При этом без использывания в дом дереве этого тега. Или как показано выше, для отображения ng-template
      `,
    },
    {
      title: 'Как оптимизировать ангуляр приложение',
      quest: `
      1.Lazy loading - ленивая подрузка модулей
      2.Стратегия запуска механизма обнаружения изменений OnPush,
      3.Использывание функции trackBy в цикле *ngFor,
      4.Использывание чистых пайпов,
      5.Web worker - чтобы вынести функцию со сложными вычислениями в параллельный поток
      6.По возможности всегда пользоваться providedIn: "root" при создании зависимости.
      Это позволит не учитывать данную ззависимость в конечном бандле при сборе.
      Делается это тришейкингом(встряской)`,
    },
    {
      title: 'Компиляции Ангуляр приложения JIT AOT',
      quest: `

      • JIT - Just-in-Time: JIT компилирует приложение в браузере во время выполнения. ng serve
      • AOT - Ahead-of-Time:  компилятор с опережением времени: компиляция AOT компилирует приложение во время сборки. npm build --aot

      JIT:
      1. Компилирует во время выполнения в браузере
      2. Увеличенный размер файлов пакета Angular
      3. Обнаружение ошибок шаблона позже во время выполнения
      4. Медленный рендеринг
      5. Больше асинхронных запросов
      6. Меньше безопас ности
      7. Меньше производительности
      8. Хорошо для разработки


      AOT:
      1. Компиляция во время сборки
      2. Меньший размер файлов пакета Angular
      3. Обнаружение ошибок шаблона раньше во время компиляции
      4. Более быстрый рендеринг
      5. Меньше асинхронных запросов
      6. Лучшая безопасность
      7. Лучшая производительность
      8. Хорошо для продакшена

      Смысл использования JIT во время ng serve:

      Быстрая разработка: JIT позволяет вам видеть изменения в реальном времени без долгих процессов сборки. Это улучшает процесс разработки и отладки.
      Удобство для разработчиков: Приложение автоматически перекомпилируется при каждом изменении кода, что облегчает эксперименты и быстрые итерации в процессе разработки.

      Смысл использования AOT в production:
      Производительность: AOT предоставляет более быстрое время запуска, так как код уже скомпилирован.
      Безопасность и оптимизации: AOT может применять различные оптимизации, а также сокращает объем кода, который отправляется на клиентскую сторону, улучшая безопасность и производительность.
      `,
    },
    {
      title: 'Иерархия инжекторов в Angular',
      quest: `
      1. NULL injector

      2. PlatformInjector

      3. RootInjector

      4. (Модели ленивой загрузки, если они есть. Обычные модули идут в root инжектор)

      5. Компонентинжектор
      `,
    },
    {
      title: 'Отличие providers и viewProviders',
      quest: `
      Когда мы провайдим зависимость с помощью viewProviders, то она у нас доступна только внутри view комонента. То есть дочерним компонентам,
      которые находятся в ng-content, она доступна не будет
      `,
    },
    {
      title: 'UseClass, UseValue, UseFactory, useExisting?',
      quest: `

     1 useClass
      Это самый простой вариант, который заключается в том, что для реализации указывается класс.
      providers: [{ provide: OptionsService, useClass: OptionsService }]

     2 useValue
      В этом варианте подставляем конкретный экземпляр значения, которое может быть любым типом данных.
      providers: [
        { provide: 'VALUE_NUMBER', useValue: 1  },
        { provide: 'VALUE_STRING', useValue: 'Текстовое значение' },
        { provide: 'VALUE2_FUNCTION', useValue: () => { return 'что-то' } },
        { provide: 'VALUE2_OBJECT', useValue: { id: 1, name: 'имя' } },
        { provide: 'VALUE2_ARRAY', useValue: [1, 2, 3] } }, ]

     3   useFactory
        Это вариант, в котором функция регистрируется как результат. Функция выполняет роль фабрики, возвращающей значение зависимости.
        providers: [{ provide: 'VALUE', useFactory: () => { return 'что-то' } }]
        Вариант useFactory отличается от варианта useValue c функцией тем, что когда возвращается функция в useValue, потом с этой
        функцией необходимо работать как с функцией, а с фабрикой получаем значение, с которым и работаем, и нет повторных вызовов функции.
        Для работы фабрики часто необходимо получать зависимости, поэтому предусмотрен механизм передачи зависимостей в функцию фабрики.
        {provide: SETTINGS_TOKEN,
        useFactory: (http: HttpClient): Observable<ISettings> => http.get<ISettings>('/assets/settings.json').pipe(shareReplay()),
        deps: [HttpClient]
        В представленном примере хотелось бы обратить внимание на свойство deps, которое осуществляет передачу зависимостей в фабрику.


     4   useExisting
        Этот вариант наиболее непонятный для новичка. Суть useExisting заключается в том, что выбирается уже существующая зависимость.
        providers: [
          { provide: 'CarService1', useClass: CarService},
          { provide: 'CarService2', useExisting: 'CarService1' }]
        Сразу отвечу на первый же вопрос – почему мы не должны написать код так:
        providers: [
          { provide: 'CarService1', useClass: CarService },
          { provide: 'CarService2', useClass: CarService }]
        Этот вариант регистрация зависимости создаст нам два экземпляра CarService. Что может доставить много не удобств
        при отладке, т.к. сервис часто хранит состояние, в результате чего произойдёт так называемый сайд-эффект.

}
      `,
    },
    {
      title: 'Как из дочернего вызвать метод родительского',
      quest: `
      В Angular дочерний компонент может вызвать метод родительского компонента с использованием @Output

      import { Component, EventEmitter, Output } from '@angular/core';

      @Component({
        selector: 'app-child',
        template: '<button (click)="sendMessage()">Send Message to Parent</button>'
      })
      export class ChildComponent {
        @Output() messageEvent = new EventEmitter<string>();

        sendMessage() {
          this.messageEvent.emit('Hello from child!');
        }
      }

      import { Component } from '@angular/core';

      @Component({
        selector: 'app-parent',
        template: '<app-child (messageEvent)="receiveMessage($event)"></app-child>'
      })
      export class ParentComponent {
        receiveMessage(message: string) {
          console.log(message);
          // Здесь можно вызвать любой метод родительского компонента
        }
      }






      `,
    },
    {
      title: 'Структурные и шаблонные директивы в ангуляр',
      quest: `
      Директива это класс с декоратором Directive, который применяется в элементу и меняет его свойства или поведение.
      Директивы добавляем в declarations модуля или импортим в компоненте(standalone)

      Директивы можно разделить на типа: шаблонные и структурные.
      Шаблонные директивы - изменяют свойства элемента, в то время как.
      Структурные директивы - изменяют макет DOM путем добавления и удаления элементов DOM

      Структурные директивы (Structural Directives):
      *ngIf, *ngFor, *ngSwitch

      Шаблонные директивы (Attribute Directives):
      [ngStyle], [ngClass], [(ngModel)]
    `,
    },
    {
      title: 'Директивы кастомные',
      quest: `
      Создание структурной директивы:

      <div *ngIfCastom="true" ></div>

      @Directive({
        selector: '[ngIfCastom]',
      })
      export class ColoryDirective {

        @Input() ngIfCastom:any

        template = inject(TemplateRef) // Элемент, к которому добавляется атрибут colory
        view = inject(ViewContainerRef) // Обертка ng-template, в которую ангуляр оборачивает элемент

        ngOnInit() {
          this.ngIfCastom && this.view.createEmbeddedView(this.template) // Добавляем в ng-template элемент, есил инпут равен true
        }
      }

      В случае использования структурной директивы с *ngIfCustom, элемент, к которому применяется директива, оборачивается в <ng-template>
       автоматически при компиляции шаблона Angular.

          Таким образом, если у вас есть следующий код: <div *ngIfCustom="true"></div>
          Angular преобразует его примерно так:
           <ng-template [ngIfCustom]="true">
            <div></div>
          </ng-template>
          В этом случае, TemplateRef будет представлять собой внутренний контент <ng-template>, включая <div>.
           И ViewContainerRef будет контейнером, в который можно вставлять или удалять это представление.


      Создание атрибутной директивы:

      <div colory="blue" #controller="colorController">awdwadwadaw</div>
      <button (click)="controller.controllerClicked()" ></button>

      @Directive({
        selector: '[colory]',
        exportAs: 'colorController', // Вызываем контроллер директивы из шаблона по этому названию
      })
      export class ColoryDirective {
        @Input() colory: any; //Принимаем в шаблоне аргумент
        @HostBinding('style.color') color = 'red'; // Изменение свойст хоста
        el = inject(ElementRef)//Получаем элемент

        @HostListener('click') clicked = () => {
          this.color = this.colory; // Меняем цвет через прослушивание событий на хосте
          console.log(this.el.nativeElement)//Выводим элемент в консоль
        };

        controllerClicked() {
          this.color = 'green';
        } // Меняем цвет через контролле в шаблоне
      }



      `,
    },
    {
      title: 'Динамические компоненты в ангуляр',
      quest: `

    Пример создания

    @Component({
      selector: 'app-dynamic',
      template: "{{name}}",

    })
    export class DynamicComponent {
      @Input() name!: string
    }

    @Component({
      selector: 'app-root',
      standalone: true,
      imports: [CommonModule, RouterModule, ReactiveFormsModule],
      template: "
        <button class="show-btn" (click)="createComponent()">Clear</button>
      <button class="remove-btn" (click)="removeComponent()">Remove</button>
      <ng-container #container></ng-container>
      ",
    })
    export class AppComponent {
      bool = true
      @ViewChild('container', { read: ViewContainerRef })
      private container!: ViewContainerRef;

      createComponent(): void {
        this.container.clear(); // Очищает template
        const component = this.container.createComponent(DynamicComponent);//Создаем новый компонент
        component.instance.name = 'Игорь' // Передача данных
      }
      removeComponent(): void {
        this.container.clear(); // Удаляем динамический компонент
      }
    }



    `,
    },
    {
      title: 'DI Внедрение зависимостей',
      quest: `
      Суть DI - в том, чтобы избежать жесткой зависимости между классами и отделить сощдание объекта от его использования.
      Это позволяет изменять засимости без изменения класса, который их использует.



    `,
    },
  ];
  PRINCIPS: QuestsArr = [
    {
      title: 'Принципы ООП',
      quest: `

      1.Инкапсуляция:
      Принцип: Сокрытие данных внутри объекта.
      Предоставление доступа к ним через функции. Например геттеры и сеттеры

      2. Наследование:
      Принцип: Создание новых классов на основе существующих.
      Это помогает переиспользовать существующий код

      3.Полиморфизм:
      Принцип: Объекты разных типов могут использовать одинаковые методы.
      Суть полиморфизма заключается в том, что мы переопределяем метод у
      наследующегося класса и можем обратиться к этому методу и получить другой результат

      4.Абстракция:
      Принцип: Создание упрощенных моделей объектов.
      Базовый класс содержит методы и свойства, которые должны быть у всех наследующих классов.
`,
    },
    {
      title: 'REST Api принципы',
      quest: `
    REST API представляет собой набор правил для взаимодействия клиента и сервера.
    То есть стандарт.

    Ресурсы:

    Принцип: Информация представляется в виде ресурсов с уникальными идентификаторами (URI).
    Пример: /users/123 представляет ресурс пользователя с идентификатором 123.
    Унификация интерфейса:

    Принцип: Использование стандартных HTTP-методов (GET, POST, PUT, DELETE) для взаимодействия с ресурсами.
    Пример: GET /users для получения списка пользователей.
    Без состояния:

    Принцип: Каждый запрос содержит всю необходимую информацию, и сервер не хранит состояние между запросами.
    Пример: Сессионные данные хранятся на клиенте, а не на сервере.
    Представление ресурсов:

    Принцип: Ресурсы могут иметь различные представления (JSON, XML), и клиенты выбирают подходящее.
    Пример: Accept: application/json в заголовке запроса для запроса JSON-представления ресурса.
    Система кэширования:

    Принцип: Используется кэширование для повышения производительности и снижения нагрузки на сервер.
    Пример: Cache-Control: max-age=3600 в заголовке для кэширования ресурса на 1 час.
    `,
    },
    {
      title: 'SOLID принципы',
      quest: `
      Принципы SOLID это принципы, которые выведены  для обеспечения гибкости, поддержки и удобства расширения приложений.

      1.Принцип единственной ответственности (Single Responsibility Principle - SRP):
      Каждый класс должен иметь только одну причину для изменения. В других словах, класс должен быть ответствен только за одну важную часть
      функциональности.
      Наприме, у нас есть API сервис, который может только лишь делать запросы и отдавать данные. Если он будет еще и как то обрабатывать эти данные,
      то принцип нарушается.
      ================================================================================================================

      2.Принцип открытости/закрытости (Open/Closed Principle - OCP):
      Программные сущности (классы, модули, функции и т. д.) должны быть открытыми для расширения, но закрытыми для модификации.
      Это означает, что можно добавлять новую функциональность, не изменяя существующий код.
      Плохой пример:

      Допустим, у нас есть интерфейс типа {
        name: string,
        id: number,
        car: string}, где в car мы пишем модель автомобиля.
      Но затем бизнес требования меняются и нам нужно знать еще и год выпуска и количество дверей машины,
      тогда нам придется переписать/изменить интерфейс на:
      {
        name: string,
        id: number,
        car: {
          model: string,
          year: number,
          doorCount: number
        }
      }.
      Правильным было бы изначально написать архитектуру интерфейса так
      {
        name: string,
        id: number,
        car: {
          model: string
        }
      }

      При таком подходе нам не нужно было бы изменять код, мы могли бы просто расширить car, добавив в него year: number, и doorCount: number.

      Пример из ангуляра:
          1.Когда нужно добавить новый маршрут, мы просто добавляем ще один объект {path: /users, component: UsersComponent}
          2.Композиция пайпов: когда нам нужно применить несколько пайпов к одному элементу, мы просто перечисляем их
          друг за другом, не меняя старый код: {{ value | uppercase | date:'yyyy-MM-dd' }}
          3.Композиция интерсепторов: мы добавляем новые интерсепторы, просто добавив их в провайде к остальным
          =====================================================================================================

      3.Третий принцип подстановки Лисков:
      Принцип: Объекты базового класса должны быть заменяемыми объектами производного класса без изменения корректности программы.
      Интерпретация:
      Если класс В наследуется от А, то объекты A может быть заменен
      классом B без нарушения функциональности программы.
      Иными словами, код, написанный для базового класса, должен корректно работать с наследуемыми классами, не зная об этом.
      Это обеспечивает поддержание подтипов и гарантирует, что замена объектов не нарушит корректность программы.
      ======================================================================================================================================
      4.Принцип разделения интерфейса (Interface Segregation Principle - ISP):
      Клиенты не должны зависеть от интерфейсов, которые они не используют. Это означает, что не следует заставлять клиентов реализовывать методы,
      которые им не нужны.

      Пример: интерфейсы жизненных циклов компонента. Если нам нужен только интерфейс ngOnInit, то мы имплементруемся только от него, а не от всех
      И нам не нужно реализовывать все методы жизненного цикла
      ======================================================================================================
      5.Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
      Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. Кроме того,
      абстракции не должны зависеть от деталей.
      Это подразумевает использование интерфейсов или абстрактных классов для связи между модулями.
      Утверждает, что сущности (классы, модули) не должны зависеть от конкретных реализаций, а и сущности и реализации
      должны зависеть от абстракций.

      Пример: DI в ангуляр. Когда нам нужен какой то сервис, мы передаем его через конструктор, и указываем интерфейс в качестве зависимости,
      а не от реализации. Мы можем в любой момент подменить реализацию, главное чтобы она соответствовала требованиям интерфейса.
      Это облегчает тестируемость класса
    `,
    },
  ];

  PATTERNS: QuestsArr = [
    {
      title: 'Модели данных DTO, VM, ENTITY и адаптеры',
      quest: `

   Адаптеры используюся для преобразования данных из одного формата в другой.
   По сути это просто функция или класс, который принимает объект, преобразовывает его и возвращает его.

   Например:
    ENTITY-адаптер используется для преобразования данных из формата DTO в формат ENTITY.
    Это типичный сценарий в веб-разработке, когда данные, полученные с бэкенда в формате DTO,
    которые предназначены для передачи по сети, требуется адаптировать к формату ENTITY,
    который используется внутри приложения. ENTITY может представлять объекты,
    с которыми работает бизнес-логика приложения, и они могут иметь дополнительные свойства, логику и методы.

    Адаптер, в данном случае, может выполнять следующие действия:

    Преобразование полей: Копирование значений полей из объекта DTO в объект ENTITY.
    Удаление или изменение свойств: Удаление или изменение свойств, которые не требуются или должны быть изменены для соответствия
    требованиям бизнес-логики.Добавление дополнительных данных: При необходимости адаптер может добавить
    дополнительные данные или свойства, которые могут быть важны для работы бизнес-логики.
    Так же адаптеры могут обратно преобразовать entity или VM формат в формат DTO, чтобы отправить объект на сервер

    Модели данных:
    DTO обычно используется для передачи данных между слоями приложения или между клиентом и сервером.
    Он может содержать только те данные, которые необходимы для передачи, уменьшая объем передаваемой информации.

    ENTITY такая модель даннных, которая будет храниться в сторе.

    VM это модель уже для отображения


    `,
    },
  ];

  categories = {
    NGRX: this.NGRX,
    HTTP: this.HTTP,
    HR_вопросы: this.HRQuestions,
    ДРУГОЕ: this.OTHER,
    CSS: this.CSS,
    JS: this.JS,
    TS: this.TS,
    RXJS: this.RXJS,
    ANGULAR: this.ANGULAR,
    PRINCIPS: this.PRINCIPS,
    BROWSER: this.BROWSER,
    PATTERNS: this.PATTERNS,
  };
}
